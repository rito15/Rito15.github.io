[
  
  {
    "title": "관리자 권한으로 CMD 열기(배치파일)",
    "url": "/posts/open-cmd-as-admin/",
    "categories": "cmd",
    "tags": "",
    "date": "2023-02-24 22:31:23 +0900",
    





    "snippet": "관리자 권한으로 CMD 여는 배치파일 만들기cmdcmd.bat@echo off&amp;gt;nul 2&amp;gt;&amp;amp;1 &quot;%SYSTEMROOT%\\system32\\cacls.exe&quot; &quot;%SYSTEMROOT%\\system32\\config\\system&quot;if &#39;%errorlevel%&#39; NEQ &#39;0&#39; (    echo.    goto UACPrompt) else ( goto gotAdmin ):UACPrompt    echo Set UAC = CreateOb..."
  },
  
  {
    "title": "URP 마테리얼이 기본 렌더파이프라인에서 분홍색으로 나타나는 이유",
    "url": "/posts/why-urp-material-shows-pink/",
    "categories": "Unity Shader, URP Shader Memo",
    "tags": "unity, csharp, shader, urp",
    "date": "2022-05-08 14:54:00 +0900",
    





    "snippet": "기본 쉐이더빌트인 렌더파이프라인에서 Standard 쉐이더를 사용하듯,URP에서는 Universal Render Pipeline/Lit 쉐이더를 기본으로 사용한다.두 쉐이더는 라이팅의 영향을 받으며,물리 기반 쉐이더(Physically-Based Shader, PBS)를 구현한다는 특징이 있다.핑크 마테리얼핑크핑크URP에서 작업한 위와 같은 씬을 빌트인 렌더파이프라인으로 옮겨오면이렇게 핑크핑크하게, 전문 용어로 ‘마젠타’ 색상으로 변해버린다.그 이유는 무엇일까?URP Lit 쉐이더경로{프로젝트 경로}\\Library\\Packag..."
  },
  
  {
    "title": "C# Shorts - 필드의 값 변화 감지하기",
    "url": "/posts/cs-detect-changes-of-field-values/",
    "categories": "C#, C# Memo - Shorts",
    "tags": "csharp",
    "date": "2022-04-03 15:40:00 +0900",
    





    "snippet": "소스 코드private int _score; // 필요하다면 _score = 123; 꼴로 초깃값 직접 설정public int Score{    // Getter에서는 단순히 대상 필드 값만 리턴    get    {        return _score;    }    // Setter 블록    set    {        // 저장된 값(_score), 현재 값(value)을 비교하여 변화 감지        if(_score != value)        {            Console.WriteLine($&quot..."
  },
  
  {
    "title": "Git - 명령어 - 7. Restore",
    "url": "/posts/memo-git-command-7-restore/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2022-03-23 22:00:00 +0900",
    





    "snippet": "Restore[1] 작업 중인 파일 상태 되돌리기git restore abc.txt  modified 상태인 파일의 변경사항을 마지막 커밋 상태로 되돌린다.[2] 스테이징 취소하기git restore --staged abc.txt  Staging Area에 있는 특정 파일을 modified 상태로 되돌린다.  파일 내용에 영향을 주지 않는다."
  },
  
  {
    "title": "Git - 명령어 - 6. Commit, Push, Pull",
    "url": "/posts/memo-git-command-6-commit-push-pull/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2022-03-23 22:00:00 +0900",
    





    "snippet": "Commit  Staging Area -&amp;gt; .git Directory  스테이징 된 데이터를 깃 히스토리 영역으로 이동시킨다.[1] 코멘트와 함께 커밋하기git commit -m &quot;comment&quot;[2] 워킹 디렉토리의 수정사항도 한번에 커밋하기git commit -am &quot;comment&quot;      git add ., git commit을 동시에 하는 효과        커밋 기록이 없는 파일은 직접 git add를 해줘야 한다.  Push[1] 원격 리포지토리에 푸시하기  로컬과 원..."
  },
  
  {
    "title": "Git - 명령어 - 5. 브랜치",
    "url": "/posts/memo-git-command-5-branch/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2022-03-23 22:00:00 +0900",
    





    "snippet": "Branch[1] 현재 브랜치 확인git branch[2] 브랜치 전체(원격 포함) 목록 확인git branch -aCheckout[1] 브랜치 이동git checkout {이동할 브랜치 이름}[2] 새로운 브랜치 생성  생성 후 해당 브랜치로 이동된다.git checkout -b {새로운 브랜치 이름}브랜치 생성/제거[1] 새로운 원격 브랜치 생성      로컬에서 새로운 브랜치를 생성한 상태        로컬의 현재 브랜치 이름과 {새로운 원격 브랜치 이름}은 일치해야 한다.  git push {원격 리포지토리 이름} {새..."
  },
  
  {
    "title": "Git - 명령어 - 4. 클론",
    "url": "/posts/memo-git-command-4-clone/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2022-03-23 22:00:00 +0900",
    





    "snippet": "Clone[1] 기본 클론git clone https://github.com/{사용자명}/{원격 리포지토리명}.git[2] 특정 브랜치만 클론git clone -b {브랜치명} https://github.com/{사용자명}/{원격 리포지토리명}.git"
  },
  
  {
    "title": "Git - 명령어 - 3. 상태, 기록",
    "url": "/posts/memo-git-command-3-status-logs/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2022-03-23 22:00:00 +0900",
    





    "snippet": "Status변경된 파일들 상태 확인하기git status  Changes to be committed:          git add를 통해 Staging Area로 이동된 파일들 목록        Changes not staged for commit:          변경되었지만 아직 스테이징 되지 않은 파일들 목록      Diff파일 변경 내용 확인하기git diff [파일명]      스테이징 되지 않은, 변경된 파일들의 내용 변경사항을 보여준다.        git diff 파일명으로 특정 파일만 변경사항을 확인할 수..."
  },
  
  {
    "title": "Git - 명령어 - 2. 저장소(Repository)",
    "url": "/posts/memo-git-command-2-repository/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2022-03-23 22:00:00 +0900",
    





    "snippet": "Init로컬 리포지토리로 만들기git init  .git 폴더가 생성된다.Remote원격 리포지토리 이름 확인하기git remote원격 리포지토리 주소 확인하기git remote -v원격 리포지토리 주소 변경하기git remote set-url origin [https://~.git]"
  },
  
  {
    "title": "Git - 명령어 - 1. 기본",
    "url": "/posts/memo-git-command-1-basic/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2022-03-23 22:00:00 +0900",
    





    "snippet": "특정 명령어의 도움말 확인하기git {명령어} -h임의 단축 명령어 만들기  예시 : git status를 git st로 사용하도록 단축 명령어 등록git config --global alias.st status자주 사용하는 명령어 모음  참고 : https://velog.io/@simchodi/Git-초기세팅-기본명렁어[1] gitignore 재적용  https://dev-jwblog.tistory.com/51git rm -r --cached .[2] 리모트# 별칭은 대부분 origingit remote -v         ..."
  },
  
  {
    "title": "유니티 - 디컴파일용 어셈블리 경로",
    "url": "/posts/unity-assembly-path-to-decompile/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2022-03-23 00:00:00 +0900",
    





    "snippet": "디컴파일러 예시  MS Disassembler, IL Spy, JetBrains DotPeek에디터 어셈블리 경로{프로젝트 경로}\\Library\\ScriptAssemblies\\Assembly-CSharp.dllStandalone 빌드 어셈블리 경로{빌드된 폴더 경로}\\{프로젝트명}_Data\\Managed\\Assembly-CSharp.dll"
  },
  
  {
    "title": "몬티 홀 문제에 대한 3가지 풀이",
    "url": "/posts/monty-hall-problem/",
    "categories": "Memo, Mathematics",
    "tags": "math",
    "date": "2022-02-05 17:00:00 +0900",
    





    "snippet": "몬티 홀 문제세 개의 문이 있다.이 중 두 개의 문 뒤에는 염소가 있고, 하나의 문 뒤에는 자동차가 있다.사회자는 자동차가 있는 문을 미리 알고 있으며,내가 하나의 문을 선택하면, 내가 선택하지 않은 두 개의 문 중 염소가 있는 문을 열어서 보여준다.그리고 이 상태에서 나는 내가 고르지 않은 닫힌 문으로 선택을 바꿀 기회를 얻게 된다.선택을 바꾸는 것이 유리할까?내가 선택을 바꿨을 때, 바꾼 문 뒤에 자동차가 있을 확률은 얼마일까?      정답 : \\(\\frac{2}{3}\\)        몬티 홀의 딜레마 : \\(\\frac{..."
  },
  
  {
    "title": "Docker - 4. Docker Compose 기초",
    "url": "/posts/docker-compose/",
    "categories": "Memo, Docker",
    "tags": "docker, memo",
    "date": "2021-12-11 14:11:00 +0900",
    





    "snippet": "참고 : Docker Network 명령어  …  [1] 네트워크 목록 표시  docker network ls      [2] 새로운 네트워크 생성  docker network create {이름}      [3] 기존 네트워크 제거  docker network rm {이름}  Docker-compose 명령어설명  …  작업 환경을 구성하기 위해 매번 컨테이너 생성, 환경 설정, 디펜던시 설정 등을 커맨드라인을 통해 직접 입력하게 되면 굉장히 번거로운 일이 아닐 수 없다.  따라서 docker-compose.yml 파일에 이..."
  },
  
  {
    "title": "Docker - 3. 도커의 기초와 주요 명령어",
    "url": "/posts/docker-basics/",
    "categories": "Memo, Docker",
    "tags": "docker, memo",
    "date": "2021-12-10 22:48:00 +0900",
    





    "snippet": "Note  명령어에서 {}는 반드시 작성해야 하는 파라미터, []는 작성하지 않아도 되는 선택적 파라미터를 의미한다.1. 이미지[1] 허브에서 이미지 찾기  …  도커 허브(https://hub.docker.com/)에서 원하는 이미지를 찾을 수 있다.    Containers 카테고리에서 이미지 탐색할 수 있고,  official image는 도커에서 관리하는 공식 이미지라는 것을 의미한다.  각 이미지를 클릭하면 세부 정보를 확인할 수 있다.      세부 정보에서 이미지 다운로드 명령어와 사용법을 확인할 수 있다.  [2..."
  },
  
  {
    "title": "Docker - 2. Windows 10 환경에서 도커 설치하기",
    "url": "/posts/install-docker-on-windows-10/",
    "categories": "Memo, Docker",
    "tags": "docker, memo",
    "date": "2021-12-09 19:43:00 +0900",
    





    "snippet": "가상화(Virtualization) 지원 확인  …  작업 관리자 - 성능 탭에서 가상화 : 사용이라고 표시되어 있어야 도커를 사용할 수 있다.    위와 같이 표시되지 않을 경우, BIOS 설정에서 가상화 옵션을 확인하여 켜주어야 한다.윈도우 에디션에 따른 차이  …  Windows Home을 사용할 경우, WSL2를 설치하여 도커 엔진을 구동할 수 있다.  Windows Pro를 사용할 경우, WSL2 또는 Hyper-V 기반으로 도커 엔진을 구동할 수 있다.  Hyper-V를 사용할 수 있더라도 WSL2가 권장된다고 하니..."
  },
  
  {
    "title": "Docker - 1. 도커 소개",
    "url": "/posts/introduction-to-docker/",
    "categories": "Memo, Docker",
    "tags": "docker, memo",
    "date": "2021-12-08 15:58:00 +0900",
    





    "snippet": "도커(Docker)란?컨테이너(Container) 기반의 오픈소스 가상화 플랫폼.운영체제(OS)가 아닌 컨테이너 단위로 실행 환경의 가상화를 제공한다.이를 통해 프로그램을 컨테이너로 추상화하여 배포 및 관리를 단순하고 효율적으로 할 수 있게 한다.도커는 리눅스(Linux) 운영체제 위에서 동작할 수 있다.현재 사용하는 운영체제가 리눅스가 아니더라도, 가상 머신 또는 WSL 등으로 리눅스를 구동할 수 있다면 도커를 사용할 수 있다.1. 도커의 장점      애플리케이션이 실제로 동작하는 환경을 가상화 및 격리할 수 있다.    ..."
  },
  
  {
    "title": "Fisher-Yates Shuffle 간단 정리",
    "url": "/posts/fisher-yates-shuffle/",
    "categories": "Algorithm, Algorithms",
    "tags": "algorithm, csharp",
    "date": "2021-12-06 18:00:00 +0900",
    





    "snippet": "1. Original Fisher-Yates Shuffle알고리즘  …    길이 n인 배열이 있다.      [0, n-1] 범위에서 무작위 인덱스를 뽑아, 그 위치의 원소를 새로운 배열의 인덱스 0 위치에 넣는다.      기존 배열에서 n-1 인덱스에 있는 원소를 구멍 뚫린 위치에 채워 넣는다.  뒤에서 한 칸씩 밀어서 빈 칸을 채우는 방법도 있겠으나, 그러면 O(n)에 해당하므로 정말 굉장히 비효율적이다.  끝에서 꺼내어 채워 넣으면 O(1)이므로 쓸만하다.      이번에는 [0, n-2] 범위에서 무작위 인덱스를 뽑..."
  },
  
  {
    "title": "유니티 - 깔끔하고 보기 좋은 변수명 짓기",
    "url": "/posts/unity-naming-variables-neatly/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-12-04 17:50:00 +0900",
    





    "snippet": "Intro코딩을 하다보면 변수의 이름을 지을 때 많은 고민을 하게 되고, 생각보다 많은 시간이 소요된다.아무 의미 없는 이름을 짓게 되면 개발을 이어 나가면서 스스로도 혼란을 겪게 될 수 있으며만일 협업을 하고 있었다면, 솔직히 혼나도 할 말이 없다.그러니 ‘보기에도 깔끔하고 한 눈에 의미를 알아볼 수 있는 이름’을 짓기 위해 언제나 고심하게 된다.Note만약 팀 내에 속해 있다면, 당연히 그 팀의 이름 규칙을 따라야 한다.이 포스팅은 아직 이름 규칙을 정하지 못한 경우 도움을 줄 수 있는기본적인 유니티 C#의 이름 규칙과 약..."
  },
  
  {
    "title": "(Amplify) Screen Effect - Pixelation",
    "url": "/posts/unity-amplify-screen-pixelation/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-11-26 16:16:00 +0900",
    





    "snippet": "Summary      화면 전체를 도트로 찍은 듯한 픽셀화 효과를 적용한다.        스크린 이펙트 적용 애셋 : Link  PreviewProperties  Pixelation          픽셀화 강도(0 ~ 0.99)      NodesDownload  2021_1126_Screen Effect_Pixelate.zip"
  },
  
  {
    "title": "유니티 - 드로우 콜과 배칭 개념 간단 정리",
    "url": "/posts/unity-draw-call-and-batching/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimization",
    "date": "2021-11-22 20:13:00 +0900",
    





    "snippet": "1. CPU와 GPU의 상호작용CPU에서 GPU에 명령하기  일반적으로 CPU에서 렌더링, 상태 변경 등의 명령을 GPU에 전달한다.  그런데 GPU가 바쁘게 작업하는 도중이라면, CPU는 GPU의 작업이 끝나기를 하염없이 기다리게 될 수 있다.  따라서 커맨드 패턴(Command Pattern)과 메시지 큐(Message Queue)에 의한 비동기 방식을 활용한다.  CPU에서 GPU에 전달할 명령(Command)을 임시 공간에 담아 두고, GPU가 여유 될 때 명령을 하나씩 꺼내어 처리한다.Command Buffer(커맨드..."
  },
  
  {
    "title": "유니티 - FixedUpdate()에서 이동, 회전 구현 시 버벅임 현상 해결하기",
    "url": "/posts/unity-fixed-update-and-stuttering/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-11-22 00:23:00 +0900",
    





    "snippet": "Update()와 FixedUpdate()Update()Update() 메소드는 프레임 당 한 번씩 호출된다.그리고 이동, 회전 등을 구현할 경우 프레임 간의 호출 간격을 고려하고단위 시간 당 일정한 수치로 기능을 구현하기 위해 Time.deltaTime을 사용한다.FixedUpdate()리지드바디를 사용할 때, 즉 물리 엔진의 기능을 이용할 때 사용하는 메소드.FixedUpdate() 메소드는 Fixed Time Step 주기(기본 0.02초)마다 한 번씩 호출되도록 보정된다.그냥 ‘호출된다’가 아니고, ‘호출되도록 보정된다..."
  },
  
  {
    "title": "유니티 - Time.deltaTime과 Time.fixedDeltaTime",
    "url": "/posts/unity-deltatime-and-fixeddeltatime/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-11-21 23:45:00 +0900",
    





    "snippet": "deltaTime과 fixedDeltaTime델타타임의 용도타겟 디바이스마다 성능 격차로 인해 프레임 수행 시간이 다를 것을 대비해 보정하기 위해 사용된다.예를 들어 A 디바이스는 1초에 10프레임, B 디바이스는 1초에 20프레임이 재생된다면그냥 Update() 내에서 프레임마다 거리를 1씩 가도록 구현했을 경우, 1초에 A는 10, B는 20만큼 이동하게 된다.하지만 원래 의도가 동일한 시간에 동일한 거리만큼 이동하도록 구현하는 것이었다면, 델타타임을 곱해주면 된다.프레임마다 1 * deltaTime만큼 이동하도록 구현하면..."
  },
  
  {
    "title": "(Amplify) Screen Effect - Chromatic Aberration",
    "url": "/posts/unity-amplify-screen-chromatic-aberration/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-11-20 01:01:00 +0900",
    





    "snippet": "Summary      색수차 효과        스크린 이펙트 적용 애셋 : Link  PreviewProperties  Red Offset          R 채널 색상의 화면 UV 진행 방향        Green Offset          G 채널 색상의 화면 UV 진행 방향        Blue Offset          B 채널 색상의 화면 UV 진행 방향        Intensity          색수차 효과 적용 강도        Circle Range Power          화면 내에서 원형 효과 범위..."
  },
  
  {
    "title": "유니티 - 쉐이더에서 파티클 시스템 커스텀 데이터(Custom Data) 사용하기",
    "url": "/posts/unity-particle-system-custom-data/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-11-19 15:00:00 +0900",
    





    "snippet": "커스텀 데이터(Custom Data)  파티클 시스템의 Custom Data 모듈에서 지정한 값을 쉐이더로 가져와 사용할 수 있다.1. 파티클 시스템 설정[1] Custom Data 모듈      Custom Data 모듈에 체크한다.        Mode를 Vector 또는 Color로 설정한다.        Vector로 설정한 경우, 사용할 채널 개수(Number of Components), 각 채널의 값을 지정한다.  [2] Renderer 모듈  Custom Vertex Streams에 체크한다.      우측 하단의..."
  },
  
  {
    "title": "유니티 - 반드시 고쳐야 하는, 잘못된 코딩 방식들",
    "url": "/posts/unity-bad-coding-practices/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-11-16 22:51:00 +0900",
    





    "snippet": "Intro별 생각 없이 흔하게 작성할 수 있지만,제대로 알고 보면 ‘절대 이렇게 작성하면 안되겠다’라고 생각할 수 있는 유니티 C# 코딩 방식들에 대해 다룹니다.편의상 본문에서는 평어로 서술합니다.Note      본문에서의 ‘자주’는 Update(), FixedUpdate(), 코루틴 내부의 while(true) 문 등에서 자주 호출되는 경우를 의미한다.        예를 들어 Update()는 매 프레임마다 한 번씩 호출되므로, 자주 호출된다고 할 수 있다.  1. 자주 호출되는 Find(), GetComponent()예시..."
  },
  
  {
    "title": "유니티 - Transform의 공간 변환 메소드 간단 메모",
    "url": "/posts/unity-transform-transformation-methods/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-11-13 00:02:00 +0900",
    





    "snippet": "1. 로컬-월드 변환[1] TransformPoint()      위치, 회전, 크기 변환을 적용한다.        방향 벡터가 아니라, 위치 벡터를 월드 위치로 변환할 때 사용한다.        메시의 로컬 정점 좌표로부터 월드 정점 좌표를 구할 때처럼, 오브젝트에 완전히 종속적인 위치 벡터를 변환할 때 사용된다.        C# 스크립트에서는 딱히 자주 쓰이지 않는다.  [2] TransformVector()      회전, 크기 변환을 적용한다.        메시의 노멀 벡터처럼 오브젝트에 종속적인 방향 벡터를 월드로 ..."
  },
  
  {
    "title": "게임 수학 - 세 점이 주어질 때 수선의 발 구하기",
    "url": "/posts/foot-of-perpendicular-in-three-vectors/",
    "categories": "Memo, Game Mathematics",
    "tags": "game, math",
    "date": "2021-11-12 18:12:00 +0900",
    





    "snippet": "수선의 발 구하기공간 상의 세 점 A, B, C가 주어져 있다.D는 C에서 직선 AB에 내린 수선의 발이다.D는 간단히 다음과 같이 구할 수 있다.\\[D = A + AB * \\frac{AB \\cdot AC}{AB \\cdot AB}\\]설명AD 벡터를 구하고, A에서 AD를 더해 D를 계산하는 방식이다.벡터 AB와 AC를 내적하면 AB의 크기와 AC를 AB에 사영한 벡터 AD의 크기를 곱한 값, 즉 |AB| * |AD|를 얻을 수 있고,벡터 AB를 자기 자신에 대해 내적하면 |AB| * |AB|를 얻을 수 있다.전자를 후자로 나누..."
  },
  
  {
    "title": "유니티 - 리지드바디와 콜라이더 간단 정리",
    "url": "/posts/unity-rigidbody-and-collider/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-11-09 14:50:00 +0900",
    





    "snippet": "리지드바디(Rigidbody)  Unity Docs      https://docs.unity3d.com/kr/2019.4/Manual/class-Rigidbody.html  ‘강체’로 번역할 수 있다.유니티 엔진에서 제공하는 기본 컴포넌트이다.리지드바디가 존재하는 게임 오브젝트는 물리 엔진의 영향을 받는다.현실감 있는 물리 시뮬레이션이 가능해지며,힘(Force)과 속도(Velocity)의 영향을 받는다.3D에서는 Rigidbody, 2D에서는 Rigidbody2D 컴포넌트를 사용한다.프로젝트 종류에 따라 잘 구분해서 사용해야..."
  },
  
  {
    "title": "유니티 - 모바일 성능 최적화",
    "url": "/posts/unity-mobile-optimization/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimization",
    "date": "2021-11-06 00:02:00 +0900",
    





    "snippet": "프로젝트 설정  …  공통      프로젝트 설정에서 불필요해 보이는 옵션들은 웬만해서 끄는 것이 성능에 좋다.    물리 엔진을 사용하지 않는 경우      Physics - Auto Simulation, Auto Sync Transforms 비활성화    알맞은 Frame Rate 설정하기      Application.targetFrameRate 설정    액션 게임 : 60fps    보드 게임 : 30fps    Vsync 설정      모바일 플랫폼에서 Vsync 설정을 끄는 것은 사실상 의미가 없을 수 있다.   ..."
  },
  
  {
    "title": "유니티 에디터 - 게임 뷰 객체 찾는 코드",
    "url": "/posts/unity-editor-find-game-view/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-11-05 02:10:00 +0900",
    





    "snippet": "Note  흔히 게임 뷰라고 알려져 있는 에디터 윈도우는 UnityEditor.PlayModeView 타입이다.  리플렉션을 통해 접근할 수 있다.Source Code  private static Type GameViewType{    get    {        if (gameViewType == null)        {            gameViewType =                AppDomain.CurrentDomain.GetAssemblies()                .SelectMany(ass =&..."
  },
  
  {
    "title": "유니티 - 키보드 입력을 통한 리지드바디 이동, 회전, 점프 기본 코드",
    "url": "/posts/unity-rigidbody-move-and-jump/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-11-04 20:30:00 +0900",
    





    "snippet": "Note      입력은 Update(), 물리 처리는 FixedUpdate()로 철저히 구분하는 것이 핵심        리지드바디를 사용한다면, 트랜스폼을 직접 조작하지 말고 반드시 FixedUpdate()에서 리지드바디를 통해서 이동시켜야만 한다.        다음과 같은 증상들이 발생한다면 Update()에서 리지드바디를 조작하고 있는지, 혹은 트랜스폼을 직접 조작하고 있는지 의심할 필요가 있다.          왠지 모르게 캐릭터가 벽을 너무 잘 뚫고 지나간다.      콜라이더에 자주 끼인다.      지터링(덜덜 떨..."
  },
  
  {
    "title": "Intel Assembly 기초 간단 정리",
    "url": "/posts/intel-assembly-memo/",
    "categories": "Memo, Assembly",
    "tags": "assembly, masm, memo",
    "date": "2021-11-02 03:54:00 +0900",
    





    "snippet": "목표  비주얼 스튜디오에서 디스어셈블러로 어셈블리 코드를 읽었을 때, 대충이라도 흐름과 동작 이해하기어셈블리 문법 종류      Intel, AT&amp;amp;T 문법이 있다.    eax, [eax] 꼴의 문법은 Intel이며,      %eax, (%eax) 꼴의 문법은 AT&amp;amp;T이다.    Intel 문법을 따르는 대표적인 예시로 MASM(Microsoft Macro Assembler), NASM(Netwide Assembler) 등이 있다.알아두기  …  어셈블리 연산의 특징  메모리 주소 간의 연산을 수..."
  },
  
  {
    "title": "유니티 - 매 프레임 처리 성능 테스트 - Update() vs 코루틴",
    "url": "/posts/unity-update-vs-coroutine-every-frame/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-11-01 15:02:00 +0900",
    





    "snippet": "실험 목적  매 프레임 호출되는 Update() 메소드, 코루틴의 성능 비교실험 조건  운영체제 : Windows 10  유니티 에디터 버전 : 2020.3.17f1  실행 환경 : 유니티 에디터, Windows Standalone Build(Mono, IL2CPP)실험 대상[1] Update()  각 컴포넌트마다 Update() 작성  UpdateEveryFrame.cs  public class UpdateEveryFrame : MonoBehaviour{    private void Update() { }}  [2] Cust..."
  },
  
  {
    "title": "Sphere-AABB Intersection",
    "url": "/posts/sphere-aabb-intersection/",
    "categories": "Memo, Game Mathematics",
    "tags": "algorithm, csharp, math",
    "date": "2021-10-26 20:22:00 +0900",
    





    "snippet": "Sphere      공간의 한 점에서부터 동일한 거리에 있는 점들의 집합        구체의 중심 좌표(Vector3), 반지름(float)을 통해 정의할 수 있다.  AABB      Axis-Aligned Bounding Box        여섯 면이 모두 각각 X, Y, Z 축에 정렬된 형태의 육면체        중심 좌표(Vector3)와 각 축의 크기(Vector3) 또는최소 좌표(Vector3)와 최대 좌표(Vector3)를 통해 정의할 수 있다.  Closest Point to AABB우선, AABB 바깥의 한 ..."
  },
  
  {
    "title": "C# - Global Mouse Hook",
    "url": "/posts/cs-global-mouse-hook/",
    "categories": "C#, C# Winform",
    "tags": "csharp, winform",
    "date": "2021-10-26 03:56:00 +0900",
    





    "snippet": "Source Code  using System;using System.Runtime.InteropServices;using System.Diagnostics;using System.Threading;using System.Collections.Generic;namespace Rito{    /*         [기능]             - 마우스 누름, 뗌, 휠 올림/내림, 휠클릭 이벤트 글로벌 후킹         [메소드]            - 후킹 시작 : Begin()            - 후킹 종료 : Stop(..."
  },
  
  {
    "title": "C# - Global Key Hook",
    "url": "/posts/cs-global-key-hook/",
    "categories": "C#, C# Winform",
    "tags": "csharp, winform",
    "date": "2021-10-26 03:55:00 +0900",
    





    "snippet": "Source Code  using System;using System.Linq;namespace Rito{    /*         [기능]            - 키 누름, 키 뗌 이벤트 글로벌 후킹        [프로퍼티]            - bool Shift   : Shift 키 누른 상태인지 여부            - bool Control : Control 키 누른 상태인지 여부            - bool Alt     : Alt 키 누른 상태인지 여부        [메소드]            - 후킹 ..."
  },
  
  {
    "title": "유니티 - Quaternion",
    "url": "/posts/unity-quaternion/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-10-24 16:00:00 +0900",
    





    "snippet": "Note회전에 대한 정의공간은 표준 기저 벡터의 집합에 의해 정의될 수 있다.표준 기저 벡터란, 쉽게 말해 해당 공간의 축 방향을 향하는 정규화된 벡터다.2D 공간, 즉 평면은 (1, 0), (0, 1)에 의해 정의될 수 있으며,3D 공간은 (1, 0, 0), (0, 1, 0), (0, 0, 1) 에 의해 정의될 수 있다.회전이란, 표준 기저 벡터를 회전시키는 것과 같다.트랜스폼이 현재 갖고 있는 회전 정보를 오일러 각으로 정의했을 때,(0, 0, 0)일 경우 해당 오브젝트의 로컬 공간 표준 기저가월드 공간의 표준 기저와 일치..."
  },
  
  {
    "title": "게임 수학 - 회전(2차원, 3차원, 4원수)",
    "url": "/posts/game-math-rotation/",
    "categories": "Memo, Game Mathematics",
    "tags": "game, math",
    "date": "2021-10-23 17:14:00 +0900",
    





    "snippet": "기초 개념기저 벡터(Basis Vector)  n차원 공간에서 임의의 벡터를 표현할 수 있는, 선형 독립 관계의 벡터  n차원 공간을 구성하려면 n개의 기저 벡터가 필요하다.표준 기저 벡터(Standard Basis Vector)  기저 벡터 중에서도 원소 중 하나의 값이 1이고, 나머지 원소가 0인 벡터  예를 들어 2차원 평면에서의 표준 기저 벡터는 (1, 0), (0, 1)이다.  공간의 축에 대응되는 벡터라고 할 수 있다.공간 변환(Space Transformation)  공간 변환이란 기존의 공간을 이루고 있던 표준기..."
  },
  
  {
    "title": "유니티 - FixedUpdate()와 Physics Loop에 대한 이해",
    "url": "/posts/unity-fixed-update-and-physics-loop/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-10-23 03:45:00 +0900",
    





    "snippet": "Update()와 Game Loop유니티 엔진의 Update()는 매 프레임 호출되며,이동, 회전, 입력, 실시간 계산 등 수많은 기능을 여기에 작성한다.그렇다면 Update()의 정체는 무엇일까?그래픽스 라이브러리를 통해 구현되는 게임은 기본적으로 Game Loop(게임 루프) 를 통해 프레임 기반 동작이 수행된다.DirectX, OpenGL, Vulkan, … 등 어떤 그래픽스 라이브러리를 사용하더라도/* Main Function */// Game Loopwhile(...){    // User Inputs..    // ..."
  },
  
  {
    "title": "게임 수학 - 벡터의 내적과 외적",
    "url": "/posts/game-math-dot-cross/",
    "categories": "Memo, Game Mathematics",
    "tags": "game, math",
    "date": "2021-10-21 16:00:00 +0900",
    





    "snippet": "내적   …  특징      내적은 벡터의 차원에 관계 없이, 동일한 차원의 벡터끼리 가능하다.    내적의 결과는 스칼라 값이다.    벡터 A, B의 내적은 A를 B에(또는 B를 A에) 투영시킨 후 두 벡터의 길이를 곱한 것과 같다.    내적은 교환 법칙, 결합 법칙이 성립한다.      주어진 벡터\\[\\begin{flalign*}\\quad A = (a_{x} \\, , \\,\\, a_{y} \\, , \\,\\, a_{z}) &amp;amp;&amp;amp;\\end{flalign*}\\]\\[\\begin{flalign*}\\quad ..."
  },
  
  {
    "title": "게임 수학 - 선과 평면, 정점 보간",
    "url": "/posts/game-math-line-plane-vertex/",
    "categories": "Memo, Game Mathematics",
    "tags": "game, math",
    "date": "2021-10-20 21:00:00 +0900",
    





    "snippet": "3D 게임 공간의 확장  벡터 공간 : 이동 벡터를 표현(w가 항상 0)  아핀 공간 : 위치 벡터를 표현(w가 항상 1)특징  벡터와 벡터는 더할 수 있다.  벡터와 점을 더하면 w = 1이므로 점이 된다.  점과 점을 더하면 w = 2가 되어 아핀 공간을 벗어나므로, 더할 수 없다.아핀 조합(Affine Combination)\\[a + b = 1\\]\\[P = aP_{1} + bP_{2}\\]\\[P = aP_{1} + (1 - a)P_{2}\\]  점 P는 (x, y, z, 1)인 아핀 공간의 위치 벡터  아핀 조합 : 아핀 공..."
  },
  
  {
    "title": "Raycast to AABB",
    "url": "/posts/raycast-to-aabb/",
    "categories": "Memo, Game Mathematics",
    "tags": "algorithm, csharp, raycast",
    "date": "2021-10-19 03:00:00 +0900",
    





    "snippet": "레이캐스트(Raycast)  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.AABB      Axis-Aligned Bounding Box        여섯 면이 모두 각각 X, Y, Z 축에 정렬된 형태의 육면체        중심 좌표(Vector3)와 각 축의 크기(Vector3) 또는최소 좌표(Vector3)와 최대 좌표(Vector3)를 통해 정의할 수 있다.  Raycast to AAP  AAP : Axis-Aligned Plane육면체는 6개의 평면으로 이루어져 ..."
  },
  
  {
    "title": "유니티 - 한 번씩만 실행되는 메소드들 순서 정리",
    "url": "/posts/unity-initialization-methods/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, editor, memo",
    "date": "2021-10-16 00:01:00 +0900",
    





    "snippet": "Note  실행되는 순서대로 작성Methods[1] [InitializeOnEnterPlayMode]      Docs    namespace UnityEditor  메소드 애트리뷰트      정적 메소드에 사용할 수 있다.    플레이 모드에 진입하고, Awake()가 호출되기 전에 딱 1회 실행된다.          씬을 재시작할 때는 실행되지 않는다.        컴포넌트로 넣지 않고, 스크립트로만 존재해도 실행된다.[InitializeOnEnterPlayMode]private static void Method(){   ..."
  },
  
  {
    "title": "유니티 - 에디터에서 스크립트로 태그, 레이어 추가하기",
    "url": "/posts/unity-add-tag-or-layer-in-script/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-10-15 17:00:00 +0900",
    





    "snippet": "Note프로젝트의 일부를 다른 프로젝트로 옮기는 경우,특정 씬에서만 사용하는 태그 또는 레이어가 존재할 수 있다.그런데 옮긴 프로젝트에서 해당 태그 또는 레이어가 존재하지 않으면직접 추가해줘야 하므로 번거롭다.따라서 아래 소스 코드를 통해 이를 자동화할 수 있다.Source Codeusing UnityEngine;using UnityEditor;public static class EditorTagLayerHelper{    /// &amp;lt;summary&amp;gt; 태그 중복 확인 및 추가 &amp;lt;/summary..."
  },
  
  {
    "title": "유니티 - 스크립트의 실행 순서를 보장할 수 없는 경우, 종속적인 작업 처리하기",
    "url": "/posts/unity-process-after-initalization/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-10-12 04:00:00 +0900",
    





    "snippet": "요약A 클래스가 B 클래스에 종속적인 작업을 수행할 때,B 클래스가 초기화 작업을 완료하기 전에 A 클래스가 작업을 요청하면 에러가 발생할 수 있다.예를 들면 서로 다른 클래스의 Awake(), Start(), OnEnable() 호출 순서를 보장할 수 없는 경우를 생각해볼 수 있다.이런 경우의 해결 방안을 알아본다.상황 예시[1] PlayerManager 클래스  Player 객체들을 리스트에 담아 관리하며, 리스트에 추가/제거할 수 있는 API를 제공한다.class PlayerManager : MonoBehaviour{  ..."
  },
  
  {
    "title": "Sphere Cast to Sphere",
    "url": "/posts/sphere-cast-to-sphere/",
    "categories": "Memo, Game Mathematics",
    "tags": "algorithm, csharp, raycast",
    "date": "2021-10-09 18:26:00 +0900",
    





    "snippet": "Sphere Cast      공간 상의 한 점에서부터 목표 지점까지 구체를 전진시켜, 구체 표면에 닿는 물체 표면을 검출한다.        레이캐스트와는 달리 구체의 반지름을 고려해야 한다.  Sphere Cast to Sphere      대상 물체가 구체인 경우에 대해서만 검사한다.        충돌 여부와 충돌 지점을 알아내는 것이 목표이다.  [1] 충돌 여부 판정충돌 지점을 계산하기 전에, 우선 충돌 여부를 판정할 필요가 있다.      A : 캐스트 시작 지점    B : 캐스트 종료 지점    S : 검사 대상 ..."
  },
  
  {
    "title": "유니티 쉐이더 - 실수 타입들",
    "url": "/posts/unity-shader-real-number-types/",
    "categories": "Unity Shader, Shader Memo",
    "tags": "unity, shader, memo",
    "date": "2021-10-07 00:48:00 +0900",
    





    "snippet": "Memo[1] float  32비트      유효 숫자 : 6자리    실수 중 정확도가 가장 높다.  실수 중 연산이 가장 느리다.      정확해야 하는 경우, 대개 사용된다.    예시 : 정점 위치, UV, 복합 스칼라 연산[2] half  16비트  유효 숫자 : 3자리      표현 범위 : -60,000.0 ~ +60,000.0    예시 : 방향 벡터, HDR 색상[3] fixed  11비트  정밀도 : 1/256      표현 범위 : -2.0 ~ +2.0    연산이 가장 빠르다.      작은 범위에서 한정..."
  },
  
  {
    "title": "유니티 - Vert/Frag 쉐이더에서 Receive Shadow, Cast Shadow 구현하기",
    "url": "/posts/unity-shader-receive-and-cast-shadow/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, shader",
    "date": "2021-10-07 00:01:00 +0900",
    





    "snippet": "Surface Shader  쉐이더를 빠르게 작성할 수 있도록 다양한 편의를 제공한다.  Surface 쉐이더 함수는 #pragma surface Surface쉐이더함수명으로 등록한다.  미리 만들어진 라이팅을 간편히 적용할 수 있다.  커스텀 라이트를 작성하는 것도 어렵지 않다.  Receive Shadow, Cast Shadow는 자동으로 적용된다.  Surface 쉐이더 함수는 기본적으로 Fragment 쉐이더 함수에 대응되며, 필요하다면 Vertex 쉐이더 함수를 따로 추가할 수 있다.   Surface Shader E..."
  },
  
  {
    "title": "C# - 배열 내부를 같은 값으로 채우기",
    "url": "/posts/cs-fill-same-values-in-array/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-10-06 22:00:00 +0900",
    





    "snippet": "Memo// 인덱스 0부터 99까지 정수 1로 채우기int[] arr = Enumerable.Repeat(1, 100).ToArray();물론 LINQ를 쓰는 만큼, 중간 버퍼의 가비지는 감안해야 한다..NET 5.0 버전이라면 Array.Fill() 메소드를 사용하면 된다.int[] arr = new int[100];Array.Fill(arr, 1); // 배열 전체에 1로 채우기"
  },
  
  {
    "title": "유니티 - 컴퓨트 버퍼를 통한 GPU 인스턴싱",
    "url": "/posts/unity-compute-buffer-gpu-instancing/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, shader, compute shader",
    "date": "2021-10-06 15:15:00 +0900",
    





    "snippet": "GPU Instancing[1] 컴퓨트 버퍼 - 메시 데이터  그려낼 메시의 정보를 컴퓨트 버퍼에 저장한다.  컴퓨트 버퍼의 stride는 4 byte(sizeof(uint))이다.  컴퓨트 버퍼의 크기는 20 byte(uint 5개)이며, 각각의 데이터는 메시에 대한 정보를 담고 있다.Mesh mesh;                     // 그려낼 메시int subMeshIndex = 0;          // 기본 : 0int instanceCount = 100_000;   // 생성할 인스턴스의 개수uint[] arg..."
  },
  
  {
    "title": "Raycast to Plane",
    "url": "/posts/raycast-to-plane/",
    "categories": "Memo, Game Mathematics",
    "tags": "algorithm, csharp, raycast",
    "date": "2021-10-03 22:22:00 +0900",
    





    "snippet": "레이캐스트(Raycast)  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.평면(Plane)평면 위의 점 P와 평면의 법선 벡터 N을 알고 있으면 평면을 정의할 수 있으며,평면 위의 임의의 점 X를 가정하여 dot(N, P - X) = 0을 통해 평면의 방정식을 정의할 수 있다.직선과 평면의 접점 찾기점 A와 점 B가 이루는 직선과 평면이 만나는 지점을 찾는다.위와 같이 A, B, P, N이 주어졌을 때,길이 d를 알아내고 이를 통해 직선과 평면의 접점 C를 알아내야 한다...."
  },
  
  {
    "title": "Raycast to Sphere",
    "url": "/posts/raycast-to-sphere/",
    "categories": "Memo, Game Mathematics",
    "tags": "algorithm, csharp, raycast",
    "date": "2021-10-02 02:02:00 +0900",
    





    "snippet": "레이캐스트(Raycast)  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.직선과 구체 표면의 접점 찾기  시작 지점에서부터 목표 지점으로 광선을 발사하여, 두 점이 이루는 직선과 교차하는 구체의 표면 지점을 찾아낸다.  3차원에서 수행하면 구체, 2차원에서 수행하면 원(Circle)의 표면을 검출할 수 있다.  직선과 구체가 생성하는 접점은 두 개가 존재할 수 있지만, 레이캐스트의 특성 상 시작 지점에 더 가까운 접점을 찾아내는 것이 목표이다.먼저, 주어진 조건은 다음과 ..."
  },
  
  {
    "title": "C# - 바이트 버퍼를 읽어서 구조체로 변환하기",
    "url": "/posts/cs-byte-buffer-to-struct/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-10-01 00:01:00 +0900",
    





    "snippet": "소스 코드메소드  /// &amp;lt;summary&amp;gt; 바이트 버퍼를 읽어서 구조체로 변환하기 &amp;lt;/summary&amp;gt;public static T? ByteBufferToStruct&amp;lt;T&amp;gt;(byte[] buffer, int offset) where T : struct{    int size = Marshal.SizeOf(typeof(T));    if (buffer.Length - offset &amp;lt; size)        return null;    // Unm..."
  },
  
  {
    "title": "유니티 쉐이더 - 빌보드(Vert/Frag)",
    "url": "/posts/unity-shader-billboard/",
    "categories": "Unity Shader, Shader Memo",
    "tags": "unity, shader, memo",
    "date": "2021-09-30 21:00:00 +0900",
    





    "snippet": "1. 일반struct appdata{    float4 vertex : POSITION;    float2 uv : TEXCOORD0;};struct v2f{    float4 vertex : SV_POSITION;    float2 uv : TEXCOORD0;};float4 Billboard(float4 vertex){    float3 camUpVec      =  normalize( UNITY_MATRIX_V._m10_m11_m12 );    float3 camForwardVec = -normalize( UNITY_MAT..."
  },
  
  {
    "title": "C# Nullable",
    "url": "/posts/cs-nullable/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-09-30 00:11:00 +0900",
    





    "snippet": "null 허용 값 타입      .Net Framework 2.0 버전부터 사용할 수 있다.        Nullable&amp;lt;T&amp;gt; 또는 T? 꼴로 사용할 수 있다.        null 값의 초기화를 허용한다.        null을 허용한다고 해서 참조형이 되는 것은 아니고, 값 타입은 그대로 값 타입이다.        힙에 할당되지 않고, 스택에 할당되는 것은 동일하다.  Nullable 클래스      정적 클래스이다.        변수를 선언할 수 없다.        Nullable&amp;lt;T..."
  },
  
  {
    "title": "유니티 - sRGB, Linear, Gamma 컬러 스페이스",
    "url": "/posts/unity-srgb-linear-gamma-color-space/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-09-29 03:21:00 +0900",
    





    "snippet": "모니터의 색상 변환  모니터는 디스크에 저장된 이미지를 화면에 출력할 때 Pow(color, 2.2) 연산을 적용해서 더 어둡게 출력한다.  이유?          베버의 법칙(Weber’s law)      사람의 시각은 어두운 부분의 밝기 변화를 부드럽지 않고 단절되게 감지한다.      그래서 어두운 부분의 화질이 떨어져 보이는 현상이 발생한다.      따라서 이를 부드럽게 감지하도록 하려면 어두운 부분을 더 풍부하게 표현할 필요가 있다.      따라서 모니터 하드웨어적으로 이런 변환을 해준다.        Pow(c..."
  },
  
  {
    "title": "유니티 - 물리 기반 먼지 시뮬레이션",
    "url": "/posts/unity-million-dust-simulation/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-09-27 17:00:00 +0900",
    





    "snippet": "목표  수십만 ~ 백만 개의 먼지를 렌더링한다.  먼지들의 움직임을 물리 기반으로 직접 구현하여 시뮬레이션한다.  진공 청소기로 먼지들을 예쁘게 빨아들인다.주요 개념Compute Buffer  큰 병렬 데이터를 GPU에 전달하거나 쉐이더끼리 공유하기 위해 사용한다.  Vert/Frag, Compute Shader에서 StructuredBuffer&amp;lt;T&amp;gt; 타입 변수로 사용할 수 있다.Graphics.DrawMeshInstancedIndirect()  컴퓨트 버퍼의 메시 데이터를 GPU Instancing을..."
  },
  
  {
    "title": "유니티 쉐이더 - 랜덤 함수들",
    "url": "/posts/unity-shader-random-functions/",
    "categories": "Unity Shader, Shader Memo",
    "tags": "unity, shader, memo",
    "date": "2021-09-26 21:19:00 +0900",
    





    "snippet": "Memo#define RM 39482.17593#define RD1 7.8671#define RD2 3.3419#define RD3 5.8912#define RP1 2.1759#define RP2 4.7921float Random11(float seed){    return frac(sin(dot(float2(RD1, seed), float2(seed, RD2))) * RM);}float2 Random12(float seed){    return float2(        frac(sin(dot(float2(RD1, seed)..."
  },
  
  {
    "title": "자료구조 - 힙(Heap), 우선순위 큐(Priority Queue)",
    "url": "/posts/heap-priority-queue/",
    "categories": "Algorithm, Data Structure",
    "tags": "algorithm, data structure, csharp",
    "date": "2021-09-24 21:03:00 +0900",
    





    "snippet": "트리 자료 구조트리(Tree)  재귀적 계층 구조  노드로 이루어져 있다.  최초의 루트 노드에서부터 시작하며, 하나의 부모 노드는 여러 개의 자식 노드를 가진다.이진 트리(Binary Tree)  각 노드가 최대 두 개의 자식만 가질 수 있는 트리 구조포화 이진 트리(Perfect Binary Tree)  모든 잎 노드(Leaf Node : 자식이 없는 노드)가 같은 계층에 위치한 노드  완전한 삼각형 꼴을 이룬 이진 트리 구조를 의미한다.완전 이진 트리(Complete Binary Tree)  마지막 계층 이전까지의 계층이..."
  },
  
  {
    "title": "C# - XmlReader",
    "url": "/posts/cs-xml-reader/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-09-21 21:52:00 +0900",
    





    "snippet": "XMLeXTensible Markup Language의 약자로, W3C에서 개발된 마크업 언어.XML의 대표적인 파생 언어로 HTML이 있다.기본적인 XML 파일의 확장자는 .xml이다.XML 문법   …  예시      패킷 데이터 목록 정의    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;!-- Packet Data List --&amp;gt;&amp;lt;packets&amp;gt; &amp;lt;!-- 루트 태그 --&..."
  },
  
  {
    "title": "(Amplify) Spawn Effect Shader",
    "url": "/posts/unity-amplify-spawn-effect-shader/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-09-18 00:01:00 +0900",
    





    "snippet": "Summary      월드 좌표의 한 점에서부터 스폰되는 효과        월드 공간의 버텍스 이동, 그리드 패턴의 디졸브 효과로 이루어져 있다.  PreviewProperties            프로퍼티명      설명      기본 값      범위                  Main Texture      메인 텍스쳐(Albedo)                            Grid Color      그리드 패턴 색상(HDR)                            Grid Tiling X    ..."
  },
  
  {
    "title": "유니티 - 모델 트랜스폼 구조 최적화하기",
    "url": "/posts/unity-optimize-model-transform/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimization, model",
    "date": "2021-09-16 00:02:00 +0900",
    





    "snippet": "문제점Skinned Mesh가 적용되는 게임 오브젝트의 경우,하이라키에서 트랜스폼 구조를 확인해보면이렇게 Bone 별로 각각 존재하여, 굉장히 많은 게임오브젝트들로 이루어져 있다.그런데 유니티 엔진에서는 부모 게임 오브젝트의 트랜스폼에 변경사항이 생기면모든 자식 트랜스폼에 변경이 발생한다.한마디로, 위와 같이 무수히 많은 자식 오브젝트가 존재하면 성능에 좋지 않다는 의미이다.해결책Project 윈도우에서 해당 모델 파일을 선택한다.인스펙터 창에서 Rig 탭을 클릭한다.여기서 만약 Optimize Game Objects 옵션이 ..."
  },
  
  {
    "title": "유니티 - UI 이미지에 구멍뚫기",
    "url": "/posts/unity-punch-ui-image/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts, mask, ugui",
    "date": "2021-09-15 15:00:00 +0900",
    





    "snippet": "Mask이런 이미지에이런 마스크를 씌우려면  Mask Image (Image, Mask 컴포넌트 존재)          Image (Image 컴포넌트 존재)      이렇게 마스크 이미지, 보여질 이미지를 부모-자식 관계로 구성하면 된다.그러면 이렇게 마스크 이미지와 겹치는 영역만 보인다.Punch반대로 마스크 이미지와 겹치는 영역만 안보이도록,마치 구멍이 뚫린 것 같이 표현하려면우선 마테리얼 하나를 만든다.그리고 프로퍼티 값들을 위와 같이 설정한다.마스크의 자식으로 있는 이미지의 Image 컴포넌트에서Material에 해당..."
  },
  
  {
    "title": "유니티 - 한글 주석 인코딩 깨지는 경우 해결하기",
    "url": "/posts/unity-editorconfig-encoding/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, editor",
    "date": "2021-09-15 02:34:00 +0900",
    





    "snippet": "Problem문제 확인비주얼 스튜디오에서는 위와 같이 잘 보이던 한글 주석이유니티 에디터에서 보면 이렇게 깨지는 경우가 있다.당장은 스크립팅에 문제가 없더라도,스크립트 파일을 전송하거나 협업을 하게 될 때 문제가 생길 수 있다.인코딩인코딩을 확인해보면EUC-KR의 확장인 코드 페이지 949(CP949)임을 알 수 있다.추후 문제가 발생하지 않도록 하려면 유니코드로 저장할 필요가 있다.SolutionEditorConfig 파일 생성비주얼 스튜디오의 솔루션 탐색기에서 솔루션을 우클릭한 뒤,추가 - 새 항목을 클릭한다.editorc..."
  },
  
  {
    "title": ".NET CIL 명령어 모음",
    "url": "/posts/dotnet-cil-instructions/",
    "categories": "C#, C# Grammar",
    "tags": "csharp, dotnet, cil, opcode, instruction",
    "date": "2021-09-14 03:55:00 +0900",
    





    "snippet": "InstructionsStack  스택 : 계산 스택(Evaluation Stack)  “스택의 값”을 언급하는 경우는 스택의 값을 꺼내어(Pop) 사용한다는 의미이다.  “스택의 두 값”을 언급하는 경우는 스택에서 두 값을 꺼내어 사용한다는 의미이다.      “스택의 두 값 A B”를 언급하는 경우, A는 스택에 먼저 넣었던 값이고 B는 그 다음에 넣은 값(Top)이다.    ld로 시작하는 명령어는 Load를 의미하며, 대상의 값을 스택에 넣는다.      ldFOO.0 명령어는 FOO 목록의 0번 인덱스에 있는 값을 스..."
  },
  
  {
    "title": "C# - if-else if vs switch-case vs Dictionary",
    "url": "/posts/cs-switch-case-vs-dictionary/",
    "categories": "C#, C# Benchmark",
    "tags": "csharp",
    "date": "2021-09-13 00:01:00 +0900",
    





    "snippet": "분기 처리특정 변수의 값에 따라 분기를 나누어 처리해야 하는 경우,일반적으로 if-else if 또는 switch-case문을 사용할 수 있다.int value = someValue;if(value == 0) DoSomething0();else if(value == 1) DoSomething1();else if(value == 2) DoSomething2();int value = someValue;switch(value){    case 0 : DoSomething0() break;    case 1 : DoSomething1..."
  },
  
  {
    "title": "(Amplify) Screen Effect - Ice (Freezing)",
    "url": "/posts/unity-amplify-screen-ice/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-09-12 01:01:00 +0900",
    





    "snippet": "Summary      화면이 가장자리부터 얼어붙는 효과        스크린 이펙트 적용 애셋 : Link  PreviewProperties  Ice Texture          얼음 효과로 사용할 텍스쳐      원하는 텍스쳐를 사용하면 된다.        Range          효과 적용 범위 (0 ~ 1)        Noise Scale          기본 값 : 4      노이즈 적용 스케일        Power A          기본 값 : 3      영역의 모양      작을수록 원형, 클수록 사각형..."
  },
  
  {
    "title": "C# Deconstructor",
    "url": "/posts/cs-deconstructor/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-09-11 04:32:00 +0900",
    





    "snippet": "Deconstructorclass Student{    public int id;    public string name;}클래스가 있다.Student student = new Student();객체도 있다.(int id, string name) = student;위와 같이 한다고 해서 객체의 필드들이 각각의 변수에 할당되지는 않는다.class Student{    public int id;    public string name;    public void Deconstruct(out int id, out string nam..."
  },
  
  {
    "title": "C# Tuple, ValueTuple",
    "url": "/posts/cs-tuple-and-value-tuple/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-09-11 03:45:00 +0900",
    





    "snippet": "NoteTuple, ValueTuple은 C# 7.0에 처음 도입되었다.두 개 이상의 타입을 함께 묶어 사용할 때,클래스나 구조체를 따로 정의하지 않고 곧바로 사용할 수 있게 해준다.Tuple클래스 튜플 타입.클래스 타입이므로 전달할 때 복사가 발생하지 않고, 참조를 전달한다.Tuple&amp;lt;T1, T2&amp;gt; 같이 명시적으로 타입명을 작성해야 한다.Tuple&amp;lt;int, float&amp;gt; tuple = (10, 20f); // 불가능아쉽게도 위와 같은 편리한 생성은 안되고,Tuple&amp;lt..."
  },
  
  {
    "title": "C# - 타입별 GetHashCode() 성능",
    "url": "/posts/cs-gethashcode-cost-by-types/",
    "categories": "C#, C# Benchmark",
    "tags": "csharp",
    "date": "2021-09-11 00:30:00 +0900",
    





    "snippet": "Curiosity타입별로 GetHashCode()의 성능 비용이 얼마나 달라지는지 간단히 확인해본다.사용자 정의 타입은 GetHashCode() 메소드를 임의로 오버라이드 하지 않고 확인한다.사용자 정의 타입public struct Struct1 { }public struct Struct2{    public int a, b, c, d, e, f, g;    public long A, B, C, D, E, F, G, H;}public struct Struct3{    public int i1, i2, i3, i4, i5, i6..."
  },
  
  {
    "title": "C# - Dictionary 탐색 성능 - 선형 탐색과 비교",
    "url": "/posts/cs-dictionary-search-cost/",
    "categories": "C#, C# Benchmark",
    "tags": "csharp",
    "date": "2021-09-11 00:01:00 +0900",
    





    "snippet": "CuriosityDictionary&amp;lt;TKey, TValue&amp;gt;는 해시 테이블 자료구조의 제네릭 구현 클래스로서,Key-Value 꼴로 데이터를 저장하고Key에 대한 해시 계산을 통해 Value를 탐색할 수 있다.그렇다면 Key-Value를 저장하는 배열의 선형 탐색과 비교했을 때,Dictionary의 탐색 성능은 어느 정도일까?BenchmarkBenchmark DotNet을 이용하여&amp;lt;TKey, TValue&amp;gt; 꼴의 딕셔너리, 이를 페어로 저장하는 배열을 비교한다.TKey와 TVal..."
  },
  
  {
    "title": "C# - Span 사용하여 문자열의 첫 문자만 대소문자 변경하기",
    "url": "/posts/cs-string-first-char-to-lower-or-upper/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-09-10 17:51:00 +0900",
    





    "snippet": "첫 문자만 간단히 대소문자 변경하기string의 API만 사용하면 아주 간단히 첫 문자만 대소문자를 변경할 수 있다.private static string FirstCharToLower(string str){    return str[0].ToString().ToLower() + str.Substring(1);}하지만 이렇게 되면 여기서 힙 할당이 너무 많이 발생한다.str[0].ToString()에서 한 번,.ToLower()에서 한 번,str.Substring(1)에서 한 번,_ + _에서 한 번.총 네 번의 힙 할당이 이..."
  },
  
  {
    "title": "유니티 - 컴퓨트 쉐이더(Compute Shader)",
    "url": "/posts/unity-compute-shader/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-09-10 02:01:00 +0900",
    





    "snippet": "Compute Shader개념  GPGPU(General-Purpose computing on GPU)를 이용해 대규모 병렬처리를 수행하는 쉐이더  동시에 수많은 대상(~ 수십만, 수백만 단위)에 대해 동일한 연산(함수)을 처리해야 할 때 사용한다.  컴퓨트 쉐이더를 연산에 사용하는 예시로 VFX Graph가 있다.  확장자는 .compute.커널(Kernal)  GPU에서 동작하는 함수를 의미한다.  함수의 이름이 곧 커널의 이름이며, #pragma kernel에도 명시해 주어야 한다.스레드 그룹(Thread Group)  ..."
  },
  
  {
    "title": "유니티 에디터 - 버전별 자동 레이아웃 컨트롤 기본 높이",
    "url": "/posts/unity-editor-layout-control-heights/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-09-08 23:00:00 +0900",
    





    "snippet": "Memo  버전별로 대응할 때 편하도록 메모GUILayout.Button()            버전      Rect 높이      하단 여백 포함 높이                  2018.3.14f1      18      21              2019.2.21f1      18      21              2019.3.0f6 *      19      21              2019.4.9f1      19      21              2019.4.17f1      19      21  ..."
  },
  
  {
    "title": "유니티 - 스크린샷 찍고 저장하기(Windows, Android)",
    "url": "/posts/unity-save-screen-shot/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-09-08 05:10:00 +0900",
    





    "snippet": "1. Unity Editor저장할 경로  $&quot;{Application.dataPath}/ScreenShots/&quot;실제 경로  &quot;[프로젝트 디렉토리]/Assets/ScreenShots/&quot;2. Standalone App저장할 경로  $&quot;{Application.dataPath}/ScreenShots/&quot;실제 경로  &quot;[실행파일명]/[실행파일명_Data]/ScreenShots/&quot;3. Android저장할 경로  $&quot;{Application.persistentDat..."
  },
  
  {
    "title": "유니티 안드로이드 토스트 메시지 표시하기",
    "url": "/posts/unity-android-toast-message/",
    "categories": "Unity, Unity Android Memo",
    "tags": "unity, android, memo",
    "date": "2021-09-07 21:42:00 +0900",
    





    "snippet": "AndroidToast SingletonUsageAndroidToast.I.ShowToastMessage(string message, ToastLength length);Option  ToastLength.Short : 약 2.5초 동안 메시지 표시  ToastLength.Long : 약 4초 동안 메시지 표시Source Code   AndroidToast.cs  using System.Collections;using System.Collections.Generic;using UnityEngine;/// &amp;lt;summ..."
  },
  
  {
    "title": "유니티 - 플랫폼별 경로들",
    "url": "/posts/unity-path-by-platform/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-09-07 19:39:00 +0900",
    





    "snippet": "경로 파라미터  &amp;lt;projectroot&amp;gt; : 유니티 에디터 프로젝트 폴더 루트 경로  &amp;lt;executablefolder&amp;gt; : 빌드된 실행 파일의 폴더 경로  &amp;lt;companyname&amp;gt; : Project Settings - Player에서 지정한 Company Name  &amp;lt;productname&amp;gt; : Project Settings - Player에서 지정한 Product Name  &amp;lt;packagename&amp;gt; : ..."
  },
  
  {
    "title": "유니티 안드로이드 권한 요청하기",
    "url": "/posts/unity-android-authority/",
    "categories": "Unity, Unity Android Memo",
    "tags": "unity, android, memo",
    "date": "2021-09-07 16:50:00 +0900",
    





    "snippet": "Memo  안드로이드의 카메라, 로컬 스토리지 등의 기능을 사용하려면 권한을 반드시 요청해야 한다.  Android 6(API Lv.23) 이상에서는 Android.Permission API를 통해 런타임에 권한을 요청할 수 있다.공통안드로이드 매니페스트 파일 경로      안드로이드 빌드를 한 번이라도 수행할 경우, 프로젝트 내에 안드로이드 매니페스트 파일이 생성된다.        구글링하면 대부분 나오는 프로젝트 루트(최상단)/Temp/StagingArea/AndroidManifest.xml 경로는 2019.3 미만 버전이..."
  },
  
  {
    "title": "유니티 안드로이드 USB 디버깅하기",
    "url": "/posts/unity-android-usb-debugging/",
    "categories": "Unity, Unity Android Memo",
    "tags": "unity, android, memo",
    "date": "2021-09-07 16:49:00 +0900",
    





    "snippet": "LogCat 패키지 설치USB 디버깅 허용  기기마다 방법이 다를 수 있다.      https://support-mirroring.mobizen.com/hc/ko/articles/216761537-USB-디버깅-모드-설정방법-안내    설정  휴대폰 정보  소프트웨어 정보      빌드 번호 연속 7번 터치    설정  개발자 옵션  USB 디버깅 체크USB 연결 및 앱 실행      USB를 안드로이드 기기에 연결한다.        빌드된 앱을 기기에서 실행한다.        Build And Run을 통해 빌드하자마자 기..."
  },
  
  {
    "title": "유니티 - 트리 구조 데이터 직렬화하기",
    "url": "/posts/unity-serialize-tree-object/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-09-06 23:23:00 +0900",
    





    "snippet": "트리(Tree) 자료구조class TreeNode{    public TreeNode[] children;}위와 같이 자기 타입의 배열 또는 컬렉션을 필드로 갖는 구조를 트리 자료구조라고 한다.자식 및 하위 노드들을 순회하기 위해 재귀적 호출을 많이 사용한다.직렬화(Serialization)데이터를 저장 또는 통신하기 위한 목적으로 변형하는 것을 의미한다.직렬화 결과의 형태로는 대표적으로 JSON, XML, byte[], string 등이 있다.그리고 유니티 엔진에서는 SerializedObject가 있다.단어 의미 그대로 직..."
  },
  
  {
    "title": "C# - 간단한 트릭 - 널 체크",
    "url": "/posts/cs-null-check-trick/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-09-06 04:40:00 +0900",
    





    "snippet": "Notepublic class MyClass{    public int[] dataArray;    public bool IsEmpty()    {        return dataArray == null || dataArray.Length == 0;    }}위와 같이 내부에 간단한 배열을 담고 있는 클래스가 있다.MyClass m = null;Console.WriteLine(m.IsEmpty());그리고 위와 같이 객체가 null인 상태에서 인스턴스 메소드를 호출하면당연히 NullReferenceException이 발생한다..."
  },
  
  {
    "title": "유니티 - IMGUI 이벤트, Getting control n&#39;s position... 예외 처리",
    "url": "/posts/unity-imgui-event-and-handle-exception/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, imgui",
    "date": "2021-09-05 18:00:00 +0900",
    





    "snippet": "IMGUI 이벤트유니티 IMGUI에서 OnGUI() 메소드가 호출되는 이벤트 타이밍은기본적으로 Layout과 Repaint가 있다.Layout은 GUI 레이아웃 컨트롤을 생성하는 단계이고,Repaint은 GUI 컨트롤들을 화면에 그려내는 단계이다.별도의 상호작용이나 간섭이 없다면 Layout과 Repaint가 반복된다.Event.current를 통해 현재 IMGUI 환경에서의 이벤트 객체를 참조할 수 있고,Event.current.type을 통해 현재 처리되는 이벤트의 종류를 알 수 있다.사용자 상호작용이 발생할 경우, 사용자..."
  },
  
  {
    "title": "C# 메모리 동기화가 필요한 경우, 아닌 경우 간단 정리",
    "url": "/posts/cs-memory-synchronization-memo/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-09-05 14:54:00 +0900",
    





    "snippet": "전혀 필요하지 않은 경우[1] 싱글 스레드 환경  전부[2] 멀티 스레드 환경      하나의 스레드가 공유 데이터를 읽는 동안 다른 스레드가 변경할 염려가 없는 경우        어떤 작업을 동시에 하나의 스레드만 해야 할 필요가 없는 경우  원자성(Atomic) 보장이 필요한 경우      여러 스레드가 공유 데이터에 쓰기를 수행하는 경우        완전히 동일한 순간에 두 개 이상의 스레드가 함께 접근하는 경우를 방지한다.        Interlocked를 많이 사용한다.  static int sharedValue =..."
  },
  
  {
    "title": "Script Line Counter(유니티 C# 스크립트 개수, 전체 라인 수 계산기)",
    "url": "/posts/unity-cs-script-line-counter/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, editor, csharp, utility",
    "date": "2021-09-04 23:23:00 +0900",
    





    "snippet": "Summary  지정한 폴더의 모든 하위 경로에서 C# 스크립트의 개수와 라인 수를 계산하여 보여줍니다.PreviewHow To Use      [Window] - [Rito] - [C# Script Line Counter]를 클릭합니다.        열린 창에서 Folder 부분에 Project 윈도우의 폴더 애셋을 드래그 앤 드롭합니다.        Folder에 아무 폴더도 지정하지 않을 경우, Assets 폴더 전체를 대상으로 합니다.        Calculate 버튼을 클릭합니다.  Download  Script L..."
  },
  
  {
    "title": "유니티 에디터 윈도우 - 스크롤 바 생성하기",
    "url": "/posts/unity-editor-window-scrollbar/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-09-04 23:11:00 +0900",
    





    "snippet": "Memo      에디터 윈도우 내의 내용들이 세로 범위를 넘어설 경우, 윈도우 우측에 스크롤 바를 생성한다.        BeginScrollView ~ EndScrollView 사이 영역에만 스크롤바를 생성하고,위아래 영역은 기존처럼 고정된다.  [SerializeField]private Vector2 scrollPos = Vector2.zero;private void OnGUI(){    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);    // Codes....    ..."
  },
  
  {
    "title": "유니티 - 폴더 애셋으로부터 폴더 절대 경로 구하기",
    "url": "/posts/unity-find-folder-path-from-folder-asset/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-09-04 19:59:00 +0900",
    





    "snippet": "1. 삽질   …  아무 생각 없이 재귀로 폴더도 찾고, 메타 파일도 찾고, Regex로 guid도 찾고…  정신 차려보니 아래와 같은 소스 코드를 짜고 있었다.  /// &amp;lt;summary&amp;gt; 지정한 폴더 애셋의 절대 경로 찾기 &amp;lt;/summary&amp;gt;private string FindFolderAssetAbsPath(DefaultAsset folderAsset){    // Note: Assets 디렉토리로부터 하위 폴더 전부 순회하며 폴더 이름 일치하는 경로 탐색    Directo..."
  },
  
  {
    "title": "C# - 하위 폴더, 파일들의 절대 경로 찾기",
    "url": "/posts/cs-memo-find-internal-path/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-09-04 19:45:00 +0900",
    





    "snippet": "Summary  재귀를 이용하여 특정 폴더 하위 경로에 있는 파일, 폴더 전체 경로 찾기Source CodeUsagestring folder = FindFolderAbsPath(@&quot;c:\\MyFolder&quot;, &quot;FolderName&quot;);string file = FindFileAbsPath(@&quot;c:\\MyFolder&quot;, &quot;FileName.txt&quot;);Code/// &amp;lt;summary&amp;gt; 특정 폴더의 모든 하위 경로에서 이름이 일치하는 폴더의 절대 ..."
  },
  
  {
    "title": "C# 비동기 Task를 사용하면서 흔히 발생하는 실수",
    "url": "/posts/cs-async-task-mistakes/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-09-04 04:09:00 +0900",
    





    "snippet": "Mistakeprivate static void Main(){    Task t = Task.Run(() =&amp;gt; TaskBody(3));    t.Wait(); // TaskBody(3)의 종료를 대기하려고 시도    Console.WriteLine(&quot;End&quot;);}static async void TaskBody(int count){    for (int i = 0; i &amp;lt; count; i++)    {        await Task.Delay(500);        Console.Wr..."
  },
  
  {
    "title": "동적 계획법(Dynamic Programming, DP)",
    "url": "/posts/dynamic-programming/",
    "categories": "Algorithm, Algorithms",
    "tags": "algorithm, csharp",
    "date": "2021-09-02 16:40:00 +0900",
    





    "snippet": "개념동적 계획법문제를 여러 개의 하위 문제들로 나누어 해결 및 기록한 뒤이를 이용해 최종적인 문제를 해결해나가는 방법.다시 말해,문제 해결 과정을 메모리에 기록하고 이를 바탕으로 이후의 문제를 해결해나가는 방법이다.한 번 기록한 적이 있다면 다시 계산할 필요 없이 곧바로 답을 도출해낼 수 있다.메모이제이션(Memoization)동적 계획법의 핵심 개념.하위 문제의 답을 구한 뒤 메모리에 저장하는 것을 의미한다.이렇게 저장된 값은 동일한 하위 문제의 결과값이 필요할 때 재계산 없이 곧바로 사용될 수 있다.예제 - 피보나치  동적..."
  },
  
  {
    "title": "C# Foreach 구문 심층 파헤치기",
    "url": "/posts/cs-grammar-foreach/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-09-02 16:00:00 +0900",
    





    "snippet": "Foreach 구문  컬렉션의 요소를 간편히 순차 탐색할 수 있는 구문List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();foreach (int item in list){    Console.WriteLine(item);}Foreach 구문이 실제로 생성하는 코드?  위의 소스 코드는 실제로 다음과 같은 코드를 생성한다고 한다.List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();List&amp;lt;int&amp;..."
  },
  
  {
    "title": "유니티 - .unitypackage 확장자 연결 끊어진 경우 해결하기",
    "url": "/posts/unity-fix-unitypackage-association/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-09-01 23:33:00 +0900",
    





    "snippet": "Note컴퓨터에 설치된 유니티 에디터 버전 중 하나를 지운 경우,.unitypackage 확장자의 연결이 끊어지는 경우가 종종 있다.확장자의 연결 프로그램이 단순한 응용 프로그램 실행이라면 상관 없지만,.unitypackage 확장자의 경우 그렇지 않기 때문에 연결프로그램 연결만으로는 해결할 수 없다.이를 비교적 간단히 해결하기 위한 두 가지 방법이 있다.아래의 두 가지 방식 중 하나를 선택해서 하면 된다.1. 명령 프롬프트에서 해결하기우선, 유니티 에디터가 설치된 경로를 알아야 한다.C:\\Program Files 경로에 들어..."
  },
  
  {
    "title": "유니티 에디터 - 빌드 직전에 동작하는 기능 작성하기",
    "url": "/posts/unity-editor-process-before-build/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-09-01 17:51:00 +0900",
    





    "snippet": "Memo  아래의 형태로 스크립트를 작성해놓으면 빌드 직전에 동작한다.#if UNITY_EDITORclass BuildPreProcessor : UnityEditor.Build.IPreprocessBuildWithReport{    public int callbackOrder =&amp;gt; 0;    public void OnPreprocessBuild(UnityEditor.Build.Reporting.BuildReport report)    {        // Do Something Here    }}#endifRefe..."
  },
  
  {
    "title": "Timescale Slider(게임 진행 속도 조절 슬라이더)",
    "url": "/posts/unity-editor-timescale-slider/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, editor, csharp, utility",
    "date": "2021-09-01 16:00:00 +0900",
    





    "snippet": "Summary      게임 진행 속도를 0% ~ 100% 사이에서 조절할 수 있는 슬라이더를 유니티 에디터 상단 재생 버튼 우측에 생성합니다.        유니티 에디터 내에서만 동작하고, 빌드 이후에는 아무런 영향을 미치지 않습니다.  테스트 완료 에디터 버전  2018.3.14f1  2019.4.9f1  2020.3.14f1  2020.3.17f1Note  2020.3.17f1 버전까지만 정상 작동합니다.PreviewDownload  Timescale Slider.unitypackageReferences  https://..."
  },
  
  {
    "title": "Screen Effect - Zoom Blur",
    "url": "/posts/unity-shader-screen-zoom-blur/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-08-31 21:33:00 +0900",
    





    "snippet": "Summary      화면 중심에서부터 바깥 방향으로 번져나가는 블러 이펙트        스크린 이펙트 적용 애셋 : Link  Properties  Center Pos          블러 중심 위치(벡터2)      기본값 : (0.5, 0.5)        Sample Count          블러 계산(샘플링) 횟수      값이 커질수록 성능 저하        Blur Size          블러 강도      범위 : 0 ~ 100        Area Range          블러가 적용될 범위 크기    ..."
  },
  
  {
    "title": "유니티 쉐이더 - 프로퍼티 메모",
    "url": "/posts/unity-shader-properties/",
    "categories": "Unity Shader, Shader Memo",
    "tags": "unity, shader, memo",
    "date": "2021-08-31 19:54:00 +0900",
    





    "snippet": "Memo  자꾸만 까먹어서 메모Properties{    _MyColor(&quot;MyColor&quot;, Color) = (1,1,1,1)    _MyVector(&quot;My Vector&quot;, Vector) = (0,0,0,0)    _MyRange(&quot;My Range&quot;, Range(0, 1)) = 1    _MyFloat(&quot;My float&quot;, Float) = 0.5    _MyInt(&quot;My Int&quot;, Int) = 1    _MyTexture2D(&quot;T..."
  },
  
  {
    "title": "(Amplify) Screen Effect - Vignette",
    "url": "/posts/unity-amplify-screen-vignette/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-31 18:04:00 +0900",
    





    "snippet": "Summary      비네트 효과        스크린 이펙트 적용 애셋 : Link  PreviewProperties  Pos X          비네트 효과가 적용될 중심의 X 좌표      범위 : 0 ~ 1        Pos Y          비네트 효과가 적용될 중심의 Y 좌표      범위 : 0 ~ 1        Radius          비네트 효과 적용 넓이      범위 : 0 ~ 2        Smoothness          비네트 효과 테두리의 부드러운 정도      범위 : 0 ~ 1    ..."
  },
  
  {
    "title": "(Amplify) Screen Effect - Vignette and Blink",
    "url": "/posts/unity-amplify-screen-vignette-and-blink/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-31 18:03:00 +0900",
    





    "snippet": "Summary      화면 전체에 비네트 효과        1인칭으로 눈을 깜빡거리는 효과        스크린 이펙트 적용 애셋 : Link  PreviewProperties  Blink          눈 감은 정도      범위 : 0 ~ 1        Brightness          화면 전체 밝기        Sight Range          시야 범위, 비네트 효과 적용 범위      범위 : 0 ~ 2      NodesDownload  2021_0831_Screen Effect_Vignette and B..."
  },
  
  {
    "title": "(Amplify) Screen Effect - Posterize(Toon)",
    "url": "/posts/unity-amplify-screen-posterize/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-31 18:02:00 +0900",
    





    "snippet": "Summary      카툰풍의 느낌을 적용하는 쉐이더        스크린 이펙트 적용 애셋 : Link  PreviewProperties  Posterize Count          색상을 구분하는 층의 개수 지정      범위 : 1 ~ 10        Intensity          효과 적용 강도 지정      범위 : 0 ~ 1      NodesDownload  2021_0830_Screen Effect_Posterize.zip"
  },
  
  {
    "title": "(Amplify) Screen Effect - Grayscale",
    "url": "/posts/unity-amplify-screen-grayscale/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-31 18:01:00 +0900",
    





    "snippet": "Summary      흑백 효과        스크린 이펙트 적용 애셋 : Link  PreviewProperties  Intensity          흑백 효과 적용 강도      범위 : 0 ~ 1      NodesDownload  2021_0831_Screen Effect_Grayscale.zip"
  },
  
  {
    "title": "유니티 에디터 - 키보드 이벤트 메모",
    "url": "/posts/unity-editor-key-events/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-31 15:33:00 +0900",
    





    "snippet": "Note// 현재 누른 키 확인bool spacePressed = Event.current.keyCode == KeyCode.Space;// 다른 이벤트(마우스 이벤트 등)와 동시에 입력한 보조 키 확인bool controlPressed = Event.current.modifiers == EventModifiers.Control;// LCtrl + 마우스 좌클릭bool ctrlAndLeftClick =     Event.current.modifiers == EventModifiers.Control &amp;amp;&amp;am..."
  },
  
  {
    "title": "Screen Effect - Blur",
    "url": "/posts/unity-shader-screen-blur/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-08-30 22:11:00 +0900",
    





    "snippet": "Summary      블러 이펙트        스크린 이펙트 적용 애셋 : Link  Properties      Resolution : 블러 적용 해상도(기본 0.5)        Intensity : 블러 적용 강도        Blur Area Mask : 블러 적용 영역을 제한할 수 있는 마스크  Preview[1] 블러 미적용[2] 블러 적용  Resolution : 0.5  Intensity : 0.4[3] 마스크 사용  사용된 마스크  결과Download  2021_0830_Screen Effect_Blur.zi..."
  },
  
  {
    "title": "유니티 쉐이더 - 상수, 상수 배열 선언하기",
    "url": "/posts/unity-shader-const-variables/",
    "categories": "Unity Shader, Shader Memo",
    "tags": "unity, shader, memo",
    "date": "2021-08-30 21:00:00 +0900",
    





    "snippet": "Memo  Pass 내부에 작성// 매크로 상수#define RANDOM_SEED 426.791// 그냥 상수static const float RandomSeed = 5417.24;// 상수 배열static const float2 dir[8] = {    float2(1, 0), float2(0, 1),   float2(-1, 0), float2(0, -1),    float2(1, 1), float2(-1, -1), float2(-1, 1), float2(1, -1)};"
  },
  
  {
    "title": "유니티 에디터 - 마우스 이벤트 메모",
    "url": "/posts/unity-editor-mouse-events/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-30 03:03:00 +0900",
    





    "snippet": "Note  OnInspectorGUI() 내에서 호출private static bool IsLeftMouseDown =&amp;gt;     Event.current.type == EventType.MouseDown &amp;amp;&amp;amp; Event.current.button == 0;private static bool IsLeftMouseDrag =&amp;gt;     Event.current.type == EventType.MouseDrag &amp;amp;&amp;amp; Event.current.button..."
  },
  
  {
    "title": "렌더링 파이프라인 간단 정리",
    "url": "/posts/rendering-pipeline/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics",
    "date": "2021-08-30 01:50:00 +0900",
    





    "snippet": "렌더링 파이프라인 구조 요약(DirectX 9 기준)입력 조립  GPU가 CPU로부터 정점 데이터를 전달 받아서 프리미티브(삼각형)들을 만든다.정점 쉐이더  Object Space에서 Clip Space까지 정점들의 공간 변환을 수행한다.래스터라이저  Clip Space의 정점 데이터를 Viewport로 변환하고, 정점 데이터를 기반으로 보간된 프래그먼트(픽셀 데이터)를 생성한다.픽셀(프래그먼트) 쉐이더  프래그먼트를 입력 받아 화면에 그려질 모든 픽셀의 색상과 깊이 값을 출력한다.출력 병합  Z-Test, Stencil Te..."
  },
  
  {
    "title": "유니티 에디터 - Built-in Icons",
    "url": "/posts/unity-editor-built-in-icons/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-29 05:02:00 +0900",
    





    "snippet": "Note      유니티 에디터에 내장된 아이콘들이 존재한다.        UnityEditor.EditorGUIUtility.IconContent(&quot;이름&quot;)을 통해 GUIContent 타입으로 로드할 수 있다.        UnityEditor.EditorGUIUtility.FindTexture(&quot;이름&quot;)을 통해 Texture2D 타입으로 로드할 수 있다.  아이콘 목록 확인      https://github.com/halak/unity-editor-icons        https://..."
  },
  
  {
    "title": "유니티 에디터 GUI - 벡터 필드의 X,Y,Z,W 레이블 변경하기",
    "url": "/posts/unity-editor-change-vector-field-labels/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-27 22:33:00 +0900",
    





    "snippet": "Note      Vector2, Vector3, Vector4 필드에는 X, Y, Z, W 레이블이 표시되며, 일반적인 방법으로는 변경할 수 없다.        리플렉션을 이용하면 이를 변경할 수 있다.  // using System.Reflection;// 커스텀 에디터 클래스 내에서 작성private Vector2 vec2;private Vector3 vec3;private Vector4 vec4;private static FieldInfo  fiVector4FieldLables;private static GUIConte..."
  },
  
  {
    "title": "유니티 에디터 - 미리 정의된 GUIStyle 목록",
    "url": "/posts/unity-editor-predefined-gui-styles/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-27 21:59:00 +0900",
    





    "snippet": "목록&quot;box&quot;&quot;button&quot;&quot;toggle&quot;&quot;label&quot;&quot;window&quot;&quot;textfield&quot;&quot;textarea&quot;&quot;horizontalslider&quot;&quot;horizontalsliderthumb&quot;&quot;verticalslider&quot;&quot;verticalsliderthumb&quot;&quot;horizontalscrollbar&quot;&quot;horizontalscr..."
  },
  
  {
    "title": "유니티 에디터 - 하이라키 윈도우 관련 코드 모음",
    "url": "/posts/unity-editor-hierarchy-window/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-27 18:00:00 +0900",
    





    "snippet": "Memo// 1. 하이라키 윈도우 타입public static Type HierarchyWindowType{    get    {        if (_hierarchyWindowType == null)            _hierarchyWindowType =                 typeof(EditorWindow).Assembly.GetTypes()                .Where(t =&amp;gt; t.Name == &quot;SceneHierarchyWindow&quot;)               ..."
  },
  
  {
    "title": "유니티 에디터 GUI - 미끄러지는 On-Off 버튼",
    "url": "/posts/unity-editor-sliding-onoff-button/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-26 03:45:00 +0900",
    





    "snippet": "Memobool onOff = true;bool onOffMoving = false;float onOffPos = 0f;string onOffStr = &quot;On&quot;;private void DrawMovingOnOffButton(){    const float LEFT = 15f;    const float RIGHT = 52f;    const float WIDTH = 40f;    const float HEIGHT = 20f;    const float MOVE_SPEED = 1f;    Rect rect = ..."
  },
  
  {
    "title": "유니티 에디터 GUI - 포커스 확인, 처리",
    "url": "/posts/unity-editor-focus/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-26 03:45:00 +0900",
    





    "snippet": "1. 컨트롤 포커스 여부 확인// 다음에 나올 GUI 컨트롤에 이름 부여GUI.SetNextControlName(&quot;Foooooooocus&quot;);// GUI 그리기EditorGUI.TextArea(rect, value, inputStyle);// 포커스 여부 확인if(GUI.GetNameOfFocusedControl() == &quot;Foooooooocus&quot;){    // Do Something..}2. 특정 컨트롤에 포커스// 다음에 나올 GUI 컨트롤에 이름 부여GUI.SetNextControlNa..."
  },
  
  {
    "title": "Screen Effect Controller(스크린 이펙트, 포스트 프로세싱)",
    "url": "/posts/unity-screen-effect-controller/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, editor, csharp, utility",
    "date": "2021-08-25 21:00:00 +0900",
    





    "snippet": "Summary      스크린 이펙트(포스트 프로세싱)를 간단히 적용할 수 있게 해주는 애셋입니다.        게임 오브젝트의 단순 활성화/비활성화 방식으로 스크린 이펙트를 적용/해제합니다.        시간에 따른 마테리얼 프로퍼티의 값 변화 애니메이션을 쉽게 제작할 수 있습니다.        유니티 타임라인에도 손쉽게 연동할 수 있습니다.        유니티 기본 렌더 파이프라인(Built-in Render Pipeline)에서 사용할 수 있습니다.          SRP, URP, HDRP에서는 사용할 수 없습니다.  ..."
  },
  
  {
    "title": "유니티 에디터 GUI - 여러 개의 커브를 겹쳐 그리기",
    "url": "/posts/unity-editor-draw-multiple-curves/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-25 03:00:00 +0900",
    





    "snippet": "NoteEditorGUI.CurveField()를 통해 AnimationCurve를 에디터에 그릴 수 있다.그런데 일반적인 방법으로는 하나의 커브 필드에 하나의 커브만 그려진다.커브 필드에는 불투명한 배경 색상이 존재하기 때문이다.  (0.337f, 0.337f, 0.337f, 1f)따라서 이를 해결하기 위해서는, 리플렉션을 이용한 편법을 사용해야 한다.private static FieldInfo fiCurveBGColor;private static Color defaultCurveBGColor;private void Draw..."
  },
  
  {
    "title": "유니티 - 에디터의 특정 영역 마우스 클릭 방지하기",
    "url": "/posts/unity-editor-block-mouse-click/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-25 02:59:00 +0900",
    





    "snippet": "MemoRect rect = ....; // 마우스 클릭 방지할 영역if (rect.Contains(Event.current.mousePosition)){    if(Event.current.type == EventType.MouseDown)        Event.current.Use();}// 이후 해당 영역에서의 모든 마우스 클릭은 무시(Button, Value Fields, ...)  위의 방식을 이용해서, 컨트롤의 색상을 변경시키지 않는 DisabledGroup을 구현할 수 있다.// 컨트롤을 그리기 전에 호출/// ..."
  },
  
  {
    "title": "유니티 에디터 스크립팅 - 버전 호환 시 고려사항들",
    "url": "/posts/unity-editor-scripting-version-compatability/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, memo",
    "date": "2021-08-23 20:00:00 +0900",
    





    "snippet": "EditorGUILayout.Space(float)   .            2019.3 미만의 버전에서는 .Space()만 존재하고 .Space(float)가 존재하지 않는다.              따라서 .Space()를 통해서는 높이 8의 고정된 여백만 넣을 수 있다.              이에 대응하기 위해서는 다음과 같이 사용하면 된다.        private static void Space(float height){#if UNITY_2019_3_OR_NEWER    EditorGUILayout.Space(h..."
  },
  
  {
    "title": "유니티 - 에디터 다크모드 여부 스크립트로 확인하기",
    "url": "/posts/unity-dark-mode-in-script/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-22 22:48:00 +0900",
    





    "snippet": "Memo확인된 버전  2019.4.9f1[1] 다크모드 여부 확인EditorGUIUtility.isProSkin;// true : 다크모드// false : 일반모드(Light)[2] 모드 변경하기UnityEditorInternal.InternalEditorUtility.SwitchSkinAndRepaintAllViews();"
  },
  
  {
    "title": "(Shorts) C# - Foreach가 실제로 생성하는 소스코드",
    "url": "/posts/cs-list-foreach-code/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-08-21 17:22:00 +0900",
    





    "snippet": "MemoSource Codeprivate List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;(10);foreach (var item in list){    Console.WriteLine(item);}Generated Codeprivate List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;(10);List&amp;lt;int&amp;gt;.Enumerator enumerator = list.GetEnumerator();w..."
  },
  
  {
    "title": "C# Switch-Case의 특징",
    "url": "/posts/cs-switch-case/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-08-20 16:49:00 +0900",
    





    "snippet": "Switch-Case 문      대상 변수에 대해, 고정된 값들을 case에 지정하여 동등 비교를 수행할 수 있다.        case가 일정 개수 미만일 경우, if-else와 동일한 방식으로 각 case를 순차적으로 확인하며 분기한다고 한다.        case가 일정 개수 이상일 경우, 메모리에 Jump Table을 생성하여 해당 case로 직접 건너뛴다고 한다.  생성되는 CIL 코드 확인하기[1] 소스 코드   .  private void IfElse(){    int value = 2;    if (value ..."
  },
  
  {
    "title": "VS2019 파일 템플릿 만들기",
    "url": "/posts/cs-vs-2019-item-template/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-08-20 16:16:00 +0900",
    





    "snippet": "Memo[1] 템플릿으로 사용할 파일 만들기[2] 템플릿 내보내기  [프로젝트] - [템플릿 내보내기]  [항목 템플릿] 선택 - [다음]  내보낼 파일에 체크  참조가 필요한 경우 선택 - [다음]  템플릿 이름과 설명 작성 후 - [마침][2] 생성된 파일 확인[3] 템플릿 확인  비주얼 스튜디오를 닫고, 다시 시작한다.  새 항목 추가 창에서 새로운 템플릿이 생성된 것을 확인할 수 있다.References  https://docs.microsoft.com/ko-kr/visualstudio/ide/how-to-create-..."
  },
  
  {
    "title": "C# - Enum을 인덱스로 사용할 경우, 배열과 딕셔너리의 참조 성능 비교",
    "url": "/posts/cs-enum-index-array-vs-dict/",
    "categories": "C#, C# Benchmark",
    "tags": "csharp",
    "date": "2021-08-19 23:11:00 +0900",
    





    "snippet": "요약  array[(int)enumValue], dict[enumValue]의 참조 성능을 비교한다.테스트 코드public enum MyEnum{    Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Nine}public float[] targetArray;public Dictionary&amp;lt;MyEnum, float&amp;gt; targetDict;[GlobalSetup]public void GlobalSetup(){    targetArray = new float[1..."
  },
  
  {
    "title": "(Amplify) Screen Effect - Shake",
    "url": "/posts/unity-amplify-screen-shake/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-19 02:55:00 +0900",
    





    "snippet": "Summary      화면 흔들림 이펙트        스크린 이펙트 적용 애셋 : Link  PreviewNodesDownload  2021_0817_Screen Effect_Shake.zip"
  },
  
  {
    "title": "(Amplify) Screen Effect - Hexagonal Pattern",
    "url": "/posts/unity-amplify-screen-hexagons/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-19 02:55:00 +0900",
    





    "snippet": "Summary      육각형 패턴 이펙트        스크린 이펙트 적용 애셋 : Link  PreviewNodesDownload  2021_0817_Screen Effect_Hexagons.zip"
  },
  
  {
    "title": "(Amplify) Screen Effect - Damage",
    "url": "/posts/unity-amplify-screen-damage/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-19 02:55:00 +0900",
    





    "snippet": "Summary      피격 시 화면 가장자리 붉어지는 이펙트        스크린 이펙트 적용 애셋 : Link  PreviewNodesDownload  2021_0817_Screen Effect_Damage.zip"
  },
  
  {
    "title": "유니티 - 하이라키 아이콘 적용 예제",
    "url": "/posts/unity-hierarchy-icon/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-18 21:20:00 +0900",
    





    "snippet": "Memo  NOTE : 아이콘 뿐만 아니라 가능한 GUI를 모두 그릴 수 있다.   …            [DisallowMultipleComponent]public class Test_HierarchyIcon : MonoBehaviour{#if UNITY_EDITOR    public static string CurrentFolderPath { get; private set; } // &quot;Assets\\......\\이 스크립트가 있는 폴더 경로&quot;    private static Texture2D iconTex..."
  },
  
  {
    "title": "유니티 - 스크립트 파일 기준 경로",
    "url": "/posts/unity-path-memo/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-18 20:40:00 +0900",
    





    "snippet": "Memopublic static string ScriptFolderFullPath { get; private set; }      // &quot;......\\이 스크립트가 위치한 폴더 경로&quot;public static string ScriptFolderInProjectPath { get; private set; } // &quot;Assets\\...\\이 스크립트가 위치한 폴더 경로&quot;public static string AssetFolderPath { get; private set; }           // &..."
  },
  
  {
    "title": "초보자를 위한 쉐이더 개념 간단 정리",
    "url": "/posts/unity-shader-concept/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics",
    "date": "2021-08-17 20:40:00 +0900",
    





    "snippet": "요약      쉐이더 : 3D 모델링의 정점 데이터로부터 화면에 출력하기 위한 픽셀의 위치와 색상을 계산하는 함수        정점 쉐이더 : 각 모델링의 3D 정점 위치들을 카메라가 바라보는 화면 위치로 변환하는 함수        래스터라이저 : 정점 쉐이더가 변환한 정점 위치로부터 화면에 출력할 2D 픽셀들을 찾아주는 장치        픽셀 쉐이더 : 2D 화면에 출력될 모든 픽셀의 최종 색상을 계산하는 함수  출처 : https://kblog.popekim.com/2011/11/01-part-1.html쉐이더(Shader..."
  },
  
  {
    "title": "유니티 - Play Mode Save Sample",
    "url": "/posts/unity-play-mode-save-sample/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-08-17 04:32:00 +0900",
    





    "snippet": "Memo  플레이모드 -&amp;gt; 에디터모드 진입 시 플레이모드의 변경사항 유지public class Sample_PlayModeSave : MonoBehaviour{    /***********************************************************************    *                           Save Play Mode Changes    *******************************************************************..."
  },
  
  {
    "title": "(Amplify) Time Easing Functions",
    "url": "/posts/unity-amplify-time-easing-functions/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-16 22:22:00 +0900",
    





    "snippet": "Note  Time 노드 기반의, 시간 진행에 따른 변화 함수 예제 모음[1]  0 ~ 1 값을 단순 선형으로 왕복할 수 있다.[2]      Power 값은 [2, 8] 범위에서 2의 배수로 넣어 주는 것이 안전하다.        사용 예시 : 심장 박동 표현  References  https://easings.net/ko"
  },
  
  {
    "title": "문자 인코딩 방식들 간단 메모",
    "url": "/posts/cs-character-encodings/",
    "categories": "C#, C# Memo",
    "tags": "csharp, encoding, unicode, utf",
    "date": "2021-08-15 21:42:00 +0900",
    





    "snippet": "Encoding      문자(char)를 코드(byte[])로 표현하는 것        반의어 : Decoding  ASCII      American Standard Code for Information Interchange, 미국 정보 교환 표준 부호        영미 문화권의 기본적인 문자들을 코드값에 대응시키기 위해 고안되었다.        영어, 숫자, 일반적인 특수 문자들을 0 ~ 127 값으로 표현한다.  Unicode      전 세계의 문자를 코드값으로 표현할 수 있도록 고안된 산업 표준        최대 2..."
  },
  
  {
    "title": "(Amplify) Electricity Shader",
    "url": "/posts/unity-amplify-electricity-shader/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-14 09:09:00 +0900",
    





    "snippet": "Summary  표면에 전기가 맴도는 효과Note      포스트프로세싱 Bloom을 넣어 주는 것이 좋다.        최적화를 위해서는 Noise Generator 노드 대신 노이즈 텍스쳐를 사용해야 한다.  PreviewPropertiesSettingsGeneral  Light Model : Unlit  Cast Shadows, Receive Shadows 체크 해제Blend Mode  MaskedNodesDownload  2021_0814_Electricity.zip"
  },
  
  {
    "title": "C# String, StringBuilder, ZString",
    "url": "/posts/cs-string-stringbuilder-and-zstring/",
    "categories": "C#, C# Benchmark",
    "tags": "csharp",
    "date": "2021-08-11 17:17:00 +0900",
    





    "snippet": "String 포맷팅의 문제점$&quot;IntValue : {123}, BoolValue : {true}&quot;;또는string.Format(&quot;IntValue {0}, BoolValue : {1}&quot;, 123, true);이런 방식의 스트링 포맷팅을 쓰는 경우가 정말 많다.정말 편리하긴 하지만,StringBuilder와 비교하면 성능도 좋지 않고심지어 가비지도 더 많이 발생시킨다.그렇다고 StringBuilder를 쓰려니 가독성이 좋지 않고 불편하다는 단점이 있다.ZString  https://github...."
  },
  
  {
    "title": "Snow Pile &amp;amp; Clear (Plane에 눈 쌓기, 지우기)",
    "url": "/posts/unity-snow-pile-and-clear/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp",
    "date": "2021-08-10 23:23:00 +0900",
    





    "snippet": "Summary      파티클이 닿는 지점에 눈 쌓기        쌓인 눈 지우기  Preview[1] 쌓기[2] 지우기Details[1] Ground 쉐이더      메인 텍스쳐의 색상을 그대로 최종 색상으로 출력한다.        메인 텍스쳐의 rgb 값 중 하나를 Height Map으로 사용하여, 버텍스 Y 위치값에 더해준다.        마테리얼을 생성하여 Plane에 적용한다.  [2] 렌더 텍스쳐      게임 시작 시 렌더 텍스쳐를 하나 생성한다.        Ground 마테리얼의 메인 텍스쳐에 렌더 텍스쳐를 넣..."
  },
  
  {
    "title": "(Amplify) Shockwave Shader",
    "url": "/posts/unity-amplify-shockwave-shader/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-08-10 20:10:00 +0900",
    





    "snippet": "Summary  Quad 기반 Shockwave 쉐이더PreviewPropertiesProgress 값이 증가함에 따라 Shockwave가 퍼져나간다.(범위 : 0 ~ 1)SettingsGeneral  Light Model : UnlitBlend Mode  TransparentNodesDownload  2021_0825_Shockwave.zip"
  },
  
  {
    "title": "C# - If vs try-catch 성능",
    "url": "/posts/cs-if-vs-try-performance/",
    "categories": "C#, C# Benchmark",
    "tags": "csharp",
    "date": "2021-08-09 14:41:00 +0900",
    





    "snippet": "Note개발을 하다보면 고민되는 경우가 많다.예외 조건을 처리할 때 if로 예외를 회피할지, try-catch로 처리할지,실제 성능은 어떻게 될지도 궁금한 부분이다.try-catch는 예외가 발생하지 않으면 성능 소모가 없다고도 하고,성능 소모가 있지만 O(1)이라고도 하고,찾아보면 다양한 주장들을 확인해볼 수 있다.대신 공통적인 사실은try-catch를 통해 예외를 핸들링하게 되면무조건 if보다 성능 소모가 크다는 점이다.try-catch는 예외 발생 지점의 스택을 거슬러 올라가서모두 추적하고 기록하게 되는데,이 과정에서 성..."
  },
  
  {
    "title": "C# ArraySegment&amp;lt;T&amp;gt;, Span&amp;lt;T&amp;gt;, Memory&amp;lt;T&amp;gt;",
    "url": "/posts/cs-arraysegment-span-memory/",
    "categories": "C#, C# Study",
    "tags": "csharp, array",
    "date": "2021-08-08 20:00:00 +0900",
    





    "snippet": "Array  https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays  https://docs.microsoft.com/ko-kr/dotnet/api/system.array?view=net-5.0특징  고정된 크기의 일차원 배열을 만든다.  배열은 관리되는 힙 메모리에 저장된다.ArraySegment&amp;lt;T&amp;gt;   …  참고       .          https://docs.microso..."
  },
  
  {
    "title": "C# - UTF8 문자열을 힙 할당 없이 byte 배열로 직렬화하기",
    "url": "/posts/cs-utf8-string-to-byte-array/",
    "categories": "C#, C# Memo",
    "tags": "csharp, file, io",
    "date": "2021-08-08 19:31:00 +0900",
    





    "snippet": "1. 힙 할당 있는 방식string str = &quot;가나다 ABC 123&quot;;byte[] byteStr = Encoding.UTF8.GetBytes(str);2. 힙 할당 없는 방식  요지 : 미리 생성된 byte[]의 특정 offset에 문자열을 직렬화하여 복제하기버퍼를 이용한 직렬화 예시using System;using System.Text;class UTF8StringBuffer{    private byte[] buffer = new byte[1024 * 100];    private int readPos ..."
  },
  
  {
    "title": "C# - 간단한 힙 메모리 디버거 (콘솔)",
    "url": "/posts/cs-heap-memory-debugger/",
    "categories": "C#, C# Memo",
    "tags": "csharp, file, io",
    "date": "2021-08-08 12:12:00 +0900",
    





    "snippet": "기능  원하는 지점의 힙 메모리 크기 기록  기록된 두 지점의 힙 메모리 크기 차이 출력주의사항  Print() 이후에는 Record()하지 않아야 한다.          Future Works : Print() 내에서 스트링을 스택에 할당하여 해결      사용 예시HeapDebugger.Record(0);int[] array = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };HeapDebugger.Record(1);new string(&quot;ABCDE&quot;);HeapDebugger.Record(2);H..."
  },
  
  {
    "title": "C# 패킷을 byte[]로 직렬화하는 다양한 방법",
    "url": "/posts/cs-serializations-to-byte-array/",
    "categories": "C#, C# Study",
    "tags": "csharp, benchmark, serialization",
    "date": "2021-08-08 02:34:00 +0900",
    





    "snippet": "Note      비교적 단순한 형태의 패킷들을 정의한다.        패킷을 다양한 방법으로 직렬화하여 byte[] 타입 버퍼에 순서대로 넣으며, 성능을 검사한다.        직렬화된 결과의 크기는 패킷 내 모든 필드의 크기의 합이어야 한다.        문자열 패킷은 어차피 공통적으로 인코딩을 거쳐야 하므로, 제외한다.        BenchmarkDotNet을 통해 벤치마크를 진행한다.  패킷 정의   Source Code  public class Packet{    public ushort size;    public..."
  },
  
  {
    "title": "C# - Benchmark DotNet",
    "url": "/posts/cs-benchmark-dotnet/",
    "categories": "C#, C# Memo",
    "tags": "csharp, benchmark",
    "date": "2021-08-07 16:16:00 +0900",
    





    "snippet": "설치  비주얼 스튜디오 - 프로젝트 - NuGet 패키지 관리 - Benchmark를 검색하여 설치사용법[1] 테스트 대상 클래스   …  [1-1] 네임스페이스       .    using BenchmarkDotNet;using BenchmarkDotNet.Attributes;          [1-2] 클래스 애트리뷰트       .          [SimpleJob()]                  https://benchmarkdotnet.org/articles/guides/choosing-run-strategy...."
  },
  
  {
    "title": "Screen Drag Selection(화면에 마우스 드래그 영역 표시하기)",
    "url": "/posts/unity-screen-drag-selection/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-08-07 01:11:00 +0900",
    





    "snippet": "PreviewSource Codeusing System.Collections;using System.Collections.Generic;using UnityEngine;using System;// 날짜 : 2021-08-07 AM 1:12:20// 작성자 : Rito/// &amp;lt;summary&amp;gt; 화면에 마우스 드래그로 사각형 선택 영역 표시하기 &amp;lt;/summary&amp;gt;public class ScreenDragSelection : MonoBehaviour{    private Vector2..."
  },
  
  {
    "title": "C# 구조체 프로퍼티, 구조체 인덱서",
    "url": "/posts/cs-struct-property-indexer/",
    "categories": "C#, C# Grammar",
    "tags": "csharp, grammar",
    "date": "2021-08-06 15:00:00 +0900",
    





    "snippet": "구조체의 특징  초기화(할당), 리턴 등의 동작을 통해 값을 전달할 경우, 구조체가 통째로 복제된다.struct MyStruct{    public float value;}class MainClass{    private MyStruct ms;    private MyStruct GetStruct()    {        return ms; // 복제하여 리턴    }    public void Main()    {        MyStruct ms1 = ms;          // 복제하여 초기화        MyStruct..."
  },
  
  {
    "title": "유니티 - 오브젝트 풀링(Object Pooling)",
    "url": "/posts/unity-object-pooling/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-08-06 01:22:00 +0900",
    





    "snippet": "1. 목표      오브젝트 풀링 기법 이해하기        Key 기반 다중 풀링 기법 이해하기        오브젝트 풀 매니저 클래스 구현하기  2. 개념게임오브젝트를 생성, 파괴하는 것은 순간적으로 큰 성능 소모 및 프레임 저하를 발생시킬 수 있다.따라서 생성, 파괴 대신 활성화, 비활성화 방식을 사용하면 순간적인 프레임 저하를 방지할 수 있다.이를 오브젝트 풀링 기법이라고 하며, 동일한 여러 개의 오브젝트를 하나의 풀(예 : 리스트, 스택, 큐)에  미리 담아 관리한다.파괴 대신 비활성화하여 풀에 저장하고, 생성 대신 ..."
  },
  
  {
    "title": "유니티 - Async Web Request",
    "url": "/posts/unity-web-request/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-08-04 15:45:00 +0900",
    





    "snippet": "Note      UnityWebRequest는 AsyncOperation 클래스를 상속받는다.        그러니까 코루틴에서 yield return으로 기다릴 수 있다.        웹페이지를 받아올 경우, 페이지 소스의 &amp;lt;head&amp;gt; 부분에서 인코딩을 꼭 확인해야 한다.  Source Code// using UnityEngine.Networking;IEnumerator WebReqRoutine(){    UnityWebRequest www = UnityWebRequest.Get(&quot;https..."
  },
  
  {
    "title": "TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기",
    "url": "/posts/cs-tcp-async-socket-chatting/",
    "categories": "C#, C# Socket",
    "tags": "csharp, thread",
    "date": "2021-08-03 03:33:00 +0900",
    





    "snippet": "  이전 포스팅에서 이어집니다.1. 채팅을 위한 패킷 설계[1] ChattingCommand 열거형  전달하는 패킷의 명령어를 미리 열거형으로 정의한다.  명령어의 종류는 크게 공통, 클라이언트의 요청, 서버의 통지 3가지로 나뉜다.   ChattingCommand.cs  /// &amp;lt;summary&amp;gt; 채팅 명령어 &amp;lt;/summary&amp;gt;public enum ChattingCommand{    /* [1] 공통 */    /// &amp;lt;summary&amp;gt; 일반 채팅 &am..."
  },
  
  {
    "title": "TCP 비동기 소켓 서버, 클라이언트 - 패킷 고려하기",
    "url": "/posts/06-cs-tcp-async-socket-with-packet.md/",
    "categories": "C#, C# Socket",
    "tags": "csharp, thread",
    "date": "2021-08-02 00:06:00 +0900",
    





    "snippet": "  이전 포스팅에서 이어집니다.ReceiveBuffer, SendBuffer  소켓 통신을 통한 데이터 전달 시 단순히 byte[]를 주고 받는 것에서 그치지 않고, 정말로 ‘패킷’을 주고 받기 위해 필요하다.ReceiveBuffer 클래스      각 세션마다 하나의 ReceiveBuffer 객체를 갖는다.        TCP 소켓 통신을 통해 수신한 패킷이 완전하지 않을 경우를 대비해 사용된다.        패킷을 수신하자마자 이를 완전히 처리하는 것이 아니라, ReceiveBuffer에 차례로 저장한다.        Re..."
  },
  
  {
    "title": "TCP 비동기 소켓 서버, 클라이언트 기본",
    "url": "/posts/05-cs-tcp-async-socket-basic.md/",
    "categories": "C#, C# Socket",
    "tags": "csharp, thread",
    "date": "2021-08-02 00:05:00 +0900",
    





    "snippet": "비동기 소켓 통신 방식Socket 객체에는 ~Async() 형태로 명명된 비동기 메소드들이 존재한다.  AcceptAsync(SocketAsyncEventArgs)  ConnectAsync(SocketAsyncEventArgs)  DisconnectAsync(SocketAsyncEventArgs)  ConnectAsync(SocketAsyncEventArgs)  ReceiveAsync(SocketAsyncEventArgs)  ReceiveFromAsync(SocketAsyncEventArgs)  SendAsync(SocketA..."
  },
  
  {
    "title": "UDP 소켓 서버, 클라이언트 기본",
    "url": "/posts/04-cs-udp-socket-server-client-basic.md/",
    "categories": "C#, C# Socket",
    "tags": "csharp, thread",
    "date": "2021-08-02 00:04:00 +0900",
    





    "snippet": "UDP 소켓 통신의 특징  서버와 클라이언트 간의 1:1 연결이 생성되지 않는다.  리스너 소켓이 필요하지 않다.  Listen(), Connect() 과정이 없다.  소켓의 .ReceiveFrom(), .SendTo() 메소드를 통해 엔드포인트와 데이터를 주고 받는다.소켓 통신 과정서버  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성  서버 소켓 객체 생성  Bind(서버 엔드포인트 정보를 서버 소켓에 연동)  클라이언트에 대응할 리모트 엔드포인트 생성  Send =&amp;gt; 리모트 엔드포인트  Receive &a..."
  },
  
  {
    "title": "TCP 소켓 서버, 클라이언트 기본",
    "url": "/posts/03-cs-tcp-socket-server-client-basic.md/",
    "categories": "C#, C# Socket",
    "tags": "csharp, thread",
    "date": "2021-08-02 00:03:00 +0900",
    





    "snippet": "소켓 정의프로토콜  데이터 전송을 위한 규약이며, 대표적으로 TCP와 UDP가 있다.IP  컴퓨터에 부여된 논리적 식별 주소Port  네트워크 상에서 통신하기 위해 호스트 내부적으로 프로세스가 할당받는 고유 번호  같은 컴퓨터 내에서 프로세스를 식별하기 위한 번호소켓 통신 과정서버  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성  Listener 소켓 객체 생성  Bind(서버 엔드포인트 정보를 Listener 소켓에 연동)  Listen(클라이언트 대기열 생성)  Accept(클라이언트 연결 수용)  Send, Rece..."
  },
  
  {
    "title": "TCP, UDP 프로토콜",
    "url": "/posts/02-cs-tcp-udp-protocols.md/",
    "categories": "C#, C# Socket",
    "tags": "csharp, thread",
    "date": "2021-08-02 00:02:00 +0900",
    





    "snippet": "TCP, UDP 프로토콜      OSI 7 Layer 중 4번째, TCP/IP 4 Layer 중 3번째인 Transport 계층의 통신을 위한 프로토콜        IP 주소와 포트 번호를 통해 대상을 식별한다.  TCP(Transmission Control Protocol)개념  데이터를 메시지 형태로 전송하기 위해 IP와 함께 사용하는 프로토콜  일반적으로 TCP와 IP를 함께 사용한다.  IP가 데이터의 전송을 처리한다면, TCP는 패킷의 추적과 관리를 담당한다.특징  연결형 서비스로 가상 회선 방식을 제공한다.  높은..."
  },
  
  {
    "title": "TCP/IP 4 계층",
    "url": "/posts/01-cs-tcp-ip-4-layer/",
    "categories": "C#, C# Socket",
    "tags": "csharp, thread",
    "date": "2021-08-02 00:01:00 +0900",
    





    "snippet": "NoteOSI 7 Layer[7] Application[6] Presentation[5] Session[4] Transport[3] Network[2] Data Link[1] PhysicalTCP/IP 4 Layer[4] Application  OSI 7 Layer의 Application(7), Presentation(6), Session(5) 계층에 해당한다.  사용자에게 응용 프로그램의 서비스를 위한 표준 인터페이스를 제공한다.      인터넷 브라우저, 텔넷, 네트워크 서비스 등이 이 계층에 속한다.    데이터 단위 :..."
  },
  
  {
    "title": "C#에서 union 구현하기",
    "url": "/posts/cs-union-in-csharp/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-07-30 18:00:00 +0900",
    





    "snippet": "C언어의 unionunion MyUnion{    int intValue;     // 4바이트    short shortValue; // 2바이트}  위처럼 C언어에는 서로 다른 타입의 변수가 동일 메모리를 사용하도록 하는 union(공용체)이 존재한다.C#에서의 union  C#에는 union 키워드가 존재하지 않지만, 편법을 통해 union 기능을 구현할 수 있다.[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Ex..."
  },
  
  {
    "title": "클래스 타입 객체가 null인지 검사하는 4가지 방법",
    "url": "/posts/cs-null-check/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-07-30 17:30:00 +0900",
    





    "snippet": "4가지 방법[1]instance == null;// 1-1. == 연산자를 오버로딩 하지 않은 경우ldloc.0ldnullceq// 1-2. == 연산자를 오버로딩한 경우ldnullcall        bool ClassName::op_Equality(class ClassName, class ClassName)[2]instance.Equals(null);ldnullcallvirt   instance bool [mscorlib]System.Object::Equals(object)[3]ReferenceEquals(instance,..."
  },
  
  {
    "title": "Infinite Horizontal Scroll (무한 횡스크롤) UI",
    "url": "/posts/unity-infinite-horizontal-scroll-ui/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, ui",
    "date": "2021-07-28 19:50:00 +0900",
    





    "snippet": "Summary  자식 UI들을 좌우로 무한히 스크롤시키는 컴포넌트PreviewHow To Use      횡스크롤 시킬 UI들을 하나의 부모 오브젝트에 묶는다.        해당 부모 오브젝트에 InfiniteHorizontalScroll 컴포넌트를 추가한다.        게임 시작 후 좌우 화살표 키를 누르면 각 방향으로 스크롤이 진행된다.  PropertiesCenter UI Size (Vector2)  중앙에 위치한 UI의 크기Edge UI Size (Vector2)  좌우 끝에 위치한 UI의 크기Space Width (..."
  },
  
  {
    "title": "(Amplify) Tree Growth Shader",
    "url": "/posts/unity-amplify-tree-growth/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-07-24 17:21:00 +0900",
    





    "snippet": "Summary  나무가 성장하는 효과 표현하기Preview1. Tree - Body프로퍼티 목록쉐이더 에디터 설정      우측 상단을 클릭하여 Blend Mode를 Masked로 변경한다.        Mask Clip Value 값을 쉐이더 에디터에서 직접 설정해도 되지만마테리얼에서 프로퍼티를 통해 조정하려면 우측의 점을 누르고 드롭다운에서 프로퍼티를 선택한다.  쉐이더 노드설명식물 성장을 표현하기 위해 사용되는 메시는 특별한 조건이 필요하다.식물이 아래에서 위로 성장하는 것을 표현하기 위해메시의 UV.Y 값은 가장 하단 ..."
  },
  
  {
    "title": "(Amplify) Sea Urchin Shader",
    "url": "/posts/unity-amplify-sea-urchin/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-07-23 15:15:00 +0900",
    





    "snippet": "Summary  가시 삐쭉삐쭉한 성게 쉐이더1. 기본PreviewProperties            프로퍼티      설명                  Edge length      테셀레이션 간격(작을수록 촘촘해진다)              Tiling      가시 개수 비율              Sharpness      가시의 뾰족한 정도              Height      가시의 길이              Body Color      구체 색상              Thron      가시 색상  ..."
  },
  
  {
    "title": "자료구조 - 해시 테이블(Hash Table)",
    "url": "/posts/hash-table/",
    "categories": "Algorithm, Data Structure",
    "tags": "algorithm, data structure, csharp",
    "date": "2021-07-20 17:14:00 +0900",
    





    "snippet": "해시 테이블(Hash Table)      데이터의 삽입, 제거, 탐색이 모두 O(1)로 매우 빠르다.        내부적으로 정렬되지는 않는다.        저장할 데이터의 수보다 더 많은 공간이 필요하다.  구현 원리      Key와 Value를 함께 저장하는 Pair 타입(클래스 또는 구조체)을 준비한다.        Pair[] 타입의 Bucket을 생성한다.        Key의 값을 해시 함수에 넣어서 배열의 Index를 계산한다.        Bucket의 Index 위치에 Pair를 삽입, 삭제, 탐색한다.  ..."
  },
  
  {
    "title": "C# 구조체가 IEquatable&amp;lt;T&amp;gt;를 상속해야 하는 이유",
    "url": "/posts/cs-why-should-inherit-iequatable/",
    "categories": "C#, C# Study",
    "tags": "csharp",
    "date": "2021-07-19 20:00:00 +0900",
    





    "snippet": "System.Object.Equals(object)C#의 모든 타입의 최상위 클래스인 Object에는 .Equals(object) 메소드가 존재한다.그리고 이를 통해 다른 값과의 동일 비교를 수행할 수 있다.구조체나 클래스를 직접 정의하고, 해당 객체로 .Equals(object)를 호출하면object.Equals(object)가 호출된다.우선, 이것이 핵심이다.박싱int a = 1;object oa = a;Value Type을 object 타입으로 캐스팅하면 박싱이 일어난다.IL_0001:  ldc.i4.1IL_0002:  ..."
  },
  
  {
    "title": "Animator Event Controller(애니메이터 이벤트 관리 컴포넌트)",
    "url": "/posts/unity-animator-event-controller/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, editor, csharp, utility",
    "date": "2021-07-17 15:15:00 +0900",
    





    "snippet": "Summary      애니메이터 내의 각 애니메이션에 대한 이벤트를 생성, 관리할 수 있는 컴포넌트        애니메이션의 프레임마다 이벤트를 추가할 수 있습니다.        플레이모드의 변경 사항은 플레이모드가 종료되어도 유지됩니다.        테스트 버전 : 2018.3.14f1, 2019.4.9f1, 2020.3.14f1  Usage Example      캐릭터가 칼을 휘두르는 순간에 검기 이펙트 생성하기        캐릭터가 걸을 때, 발이 땅에 닿는 순간마다 발소리 재생하기  Preview0. Download..."
  },
  
  {
    "title": "파티클 시스템 예제 - 12 - Sword Aura",
    "url": "/posts/unity-particle-system-example-12-sword-aura/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-07-11 14:55:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 작업 환경 구성  2. 하이라키 구성  3. Aura 이펙트  4. Smoke 이펙트  5. Spark 이펙트  6. Glow 이펙트Preview목표  검 모델링에 부착하여 사용할 수 있는, 타오르는 듯한 이펙트 만들기준비물검 모델링  https://assetstore.unity.com/packages/3d/props/weapons/free-low-poly-swords-189978Additive 마테리얼들과 텍스쳐  SwordAura, SwordSmoke, PointGlow  SwordAura_Re..."
  },
  
  {
    "title": "C# TLS(Thread Local Storage)",
    "url": "/posts/08-cs-thread-local-storage/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:08:00 +0900",
    





    "snippet": "메모리 구조TLS(Thread Local Storage)Data 영역의 전역 변수, Heap 영역의 객체는 모든 스레드가 공유한다.그리고 Stack 영역의 지역 변수(또는 멤버 변수)는 해당 블록 내에서만 사용된다.따라서 기본적으로 각각의 스레드마다 고유하게 갖는 메모리 영역은 없다.이를 만들어 줄 수 있는 것이 바로 TLS이다.TLS는 각각의 스레드마다 자기만의 변수를 저장할 수 있게 해준다.따라서 이를 활용하여, 공유 변수로 인해 빈번한 스레드 동기화가 일어날 수 있는 경우임시로 TLS에 저장하고 나중에 공유 변수에 동기화..."
  },
  
  {
    "title": "C# Thread Synchronization and Locks",
    "url": "/posts/07-cs-thread-synchronization/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:07:00 +0900",
    





    "snippet": "동기화 영역에 따른 구분1. 유저 모드 동기화      유저 객체(커널에서 제공하지 않는 객체)를 사용한다.        대표적으로 크리티컬 섹션(Critical Section), 인터락(Interlocked)이 있다.        커널 모드 동기화보다 빠르다.        동일 프로세스 내에서만 동기화 가능하다.  2. 커널 모드 동기화      커널 객체를 사용한다.        대표적으로 뮤텍스(Mutex), 세마포어(Semaphore), 이벤트(Event)가 있다.        다른 프로세스에 존재하는 스레드 간 동기화..."
  },
  
  {
    "title": "C# ReaderWriterLock",
    "url": "/posts/06-cs-reader-writer-lock/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:06:00 +0900",
    





    "snippet": "Reader Writer Lock스레드 간에 공유되는 데이터가 있을 때,항상 모든 스레드가 그 데이터를 읽고 쓰는 것은 아니다.어떤 스레드는 해당 데이터를 읽기만 하고,어떤 스레드는 해당 데이터를 쓰기만 하는 구조로 이루어져 있을 수 있다.그리고 소수의 쓰기 스레드가 상대적으로 적은 횟수로 쓰기를 수행하고,다수의 읽기 스레드가 상대적으로 빈번하게 읽기를 수행하는 경우가 많다.이런 경우에도 일반적인 락을 구현하여 읽기/쓰기를 수행하는 동안에 항상 락을 설정하고 해제한다면데이터를 단순히 읽기만 하여 값이 변경되지 않는 상황에도 불..."
  },
  
  {
    "title": "C# AutoResetEvent",
    "url": "/posts/05-cs-auto-reset-event/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:05:00 +0900",
    





    "snippet": "이벤트(Event) 동기화 기법기존의 락과는 조금 다르게,락을 얻고자 하는 각각의 스레드만 직접 락을 설정하고 해제할 수 있는 것이 아니라제 3자도 락을 설정/해제할 수 있는 방식이다.여기서 제 3자는 커널을 의미하며커널 영역으로 요청을 보내기 때문에 다른 방식보다 성능 소모가 좀더 크다.그리고 기존의 락 방식과 동일하게 사용될 수도 있다.ManualResetEvent  C#에서 이벤트 동기화가 구현된 형태.객체 생성ManualResetEvent mre = new ManualResetEvent(true);  생성자에는 bool..."
  },
  
  {
    "title": "C# Context Switching, Sleep, Yield",
    "url": "/posts/04-cs-context-switching/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:04:00 +0900",
    





    "snippet": "컨텍스트 스위칭(Context Switching)현재 실행 되는 스레드가 있다면, 그 스레드는 CPU의 자원을 할당받아 동작하는 것이다.동시에 실행될 수 있는 스레드의 개수는 사실 CPU 코어의 개수 이하인데,예를 들어 CPU 코어가 4개라면 동시에 4개까지의 스레만 자원을 할당받아 동작할 수 있는 것이다.그런데 CPU 코어가 4개라고 해도 실제로 5개 이상의 스레드가 동시에 동작할 수 있다.그 이유는 컨텍스트 스위칭과 시분할(Time Slicing) 기법 때문이다.운영체제 내부에는 스레드 스케줄러라는 것이 존재하며,현재 실행..."
  },
  
  {
    "title": "C# Spin Lock",
    "url": "/posts/03-cs-spinlock/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:03:00 +0900",
    





    "snippet": "스핀 락(Spin Lock) 개념스레드 동기화를 위해 락을 걸고 크리티컬 섹션에 진입할 경우, 대기하는 스레드는 블록된다.다시 말해, 크리티컬 섹션에 진입하려고 대기하는 스레드는 CPU 점유를 포기하게 된다.그리고 CPU 자원이 현재 활성화된 다른 스레드에게 넘어가게 되는데, 이 때 컨텍스트 스위칭이 발생하며 그에 따른 오버헤드 또한 발생한다.스핀 락은 크리티컬 섹션의 진입을 위해 대기할 때도 CPU 점유를 포기하지 않고 계속 기다리는 형태를 의미한다.이를 바쁜 대기(Busy Waiting)라고 하며, 컨텍스트 스위칭이 발생하..."
  },
  
  {
    "title": "C# Monitor, lock",
    "url": "/posts/02-cs-monitor-and-lock/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:02:00 +0900",
    





    "snippet": "Critical Section(임계 영역)  여러 프로세스 또는 여러 스레드가 공유 자원에 접근할 때 한 번에 하나만 접근할 수 있도록 보장해주는 영역  C#에서는 대표적으로 Monitor 클래스 또는 lock() 구문을 통해 만들 수 있다.Monitor 클래스      크리티컬 섹션을 만들어줄 수 있다.        Enter(진입), Exit(탈출)로 이루어져 있다.     Source Code  class Program{    // 크리티컬 섹션을 위한 매개체    private static readonly object ..."
  },
  
  {
    "title": "C# Interlocked",
    "url": "/posts/01-cs-interlocked/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-08 01:01:00 +0900",
    





    "snippet": "Race Conditionclass Program{    private const int Count = 500000;    private static int number = 0;    private static void ThreadBody1()    {        for (int i = 0; i &amp;lt; Count; i++)            number++;    }            private static void ThreadBody2()    {        for (int i = 0; i &amp;lt;..."
  },
  
  {
    "title": "C# Parallel",
    "url": "/posts/cs-parallel/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-07 19:07:00 +0900",
    





    "snippet": "Parallel 클래스      반복적인 병렬 처리를 손쉽게 작성할 수 있는 API를 제공한다.        ThreadPool 기반으로 작성되어, ThreadPool의 현재 스레드 개수를 차지하며 최소/최대 스레드 개수에 영향을 받는다.        ThreadPool의 스레드 뿐만 아니라 호출 스레드도 병렬 처리에 포함된다.        동기적으로 수행된다. (호출 스레드가 병렬 처리의 종료를 자동적으로 대기한다.)  Parallel.For()  for문의 형태와 유사하게 병렬처리를 수행할 수 있다.[1] 기초Paralle..."
  },
  
  {
    "title": "유니티 - 비동기 씬 로드",
    "url": "/posts/unity-load-scene-async/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-07-06 16:32:00 +0900",
    





    "snippet": "GIFSource Code   Source Code  using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.SceneManagement;// 날짜 : 2021-07-06 PM 3:02:23// 작성자 : Rito/// &amp;lt;summary&amp;gt; /// 비동기 씬 로드/// &amp;lt;/summary&amp;gt;public class ..."
  },
  
  {
    "title": "C# async Task",
    "url": "/posts/cs-async-task/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-06 03:34:00 +0900",
    





    "snippet": "비동기 작업 : async-await      Task를 Thread처럼 사용하는 대신, 비동기 작업을 위해 사용할 수 있다.        async, await 키워드를 이용해 이루어지는 비동기 작업은 기존의 멀티 스레딩과는 다른 방식으로 이루어진다.        async-await 작업은 Parallel이 아닌, Concurrent하게 이루어진다. (중요)        동일 스레드에서 여러 개의 작업을 동시 처리할 수 있다. (Concurrent 하므로)        실행되는 스레드가 Sleep()하고 있다면 그 동안은 ..."
  },
  
  {
    "title": "C# Task",
    "url": "/posts/cs-task/",
    "categories": "C#, C# Threading",
    "tags": "csharp, thread",
    "date": "2021-07-06 03:33:00 +0900",
    





    "snippet": "Task      Task는 ThreadPool을 기반으로 작성된 라이브러리이다.        내부적으로 ThreadPool의 스레드 개수를 차지하며, ThreadPool의 스레드 개수 제한에 영향을 받는다.        가벼운 비동기 작업에 특화되어 있다.        Thread.Abort()처럼 간단히 종료할 수 없다.        작업이 완료된 Task 객체는 다시 수행될 수 없다.  1. 생성, 실행, 대기[1] 개별 객체 정의      스레드 바디로 사용될 메소드를 미리 정의한다.        정의한 메소드 또는 람..."
  },
  
  {
    "title": "(Amplify) Shield Shader",
    "url": "/posts/unity-amplify-shield-shader/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-07-05 03:33:00 +0900",
    





    "snippet": "Summary  Sphere 메시에 사용하는 쉴드 쉐이더PreviewPropertiesSettingsBlend Mode  TransparentNodesDownload  2021_0704_Shield.zip"
  },
  
  {
    "title": "(Amplify) World Position Offset(Black Hole) Shaders",
    "url": "/posts/unity-amplify-world-position-offset-shaders/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-07-04 17:00:00 +0900",
    





    "snippet": "Summary  특정 월드 좌표로 빨려 들어가는 효과1. Simple Move  현재 좌표로부터 타겟 위치까지 T(0 ~ 1) 값에 따라 선형 보간하여 단순 이동2. Procedural Move      현재 좌표로부터 타겟 위치까지 T(0 ~ 1) 값에 따라 선형 보간하여 빨려 들어가는 효과        (버텍스 -&amp;gt; 타겟 위치) 방향 벡터와 노멀 벡터의 내적 결과값을 마스크로 사용한다.  3. Dramatic Move      현재 좌표로부터 타겟 위치까지 T(0 ~ 1) 값에 따라 선형 보간하여 빨려 들어가는..."
  },
  
  {
    "title": "(Amplify) Directional 2 Color Dissolve Shader",
    "url": "/posts/unity-amplify-2-color-dissolve/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-07-03 18:00:00 +0900",
    





    "snippet": "Summary      디졸브 방향을 직접 지정할 수 있는 디졸브 쉐이더        디졸브 효과 색상 2가지를 지정할 수 있다.        포스트 프로세싱 Bloom 효과가 반드시 필요하다.          Preview 설정 : Intensity 3, Threshold 0.9      PreviewPropertiesSettingsBlend Mode  TransparentStep by Step[1] 디졸브 기본디졸브(Dissolve) 쉐이더를 만드려면 우선 UV에 따라 연속된 단일 채널 값이 분포하는,예를 들면 UV.x나 ..."
  },
  
  {
    "title": "(Amplify) Magical Orb Shader",
    "url": "/posts/unity-amplify-magical-orb/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-07-03 17:00:00 +0900",
    





    "snippet": "PreviewPropertiesSettingsGeneral  Light Model - UnlitBlend Mode  TransparentNodes+ 추가 : Twirl, Normal From Height가 없는 구버전 노드Download  2021_0703_Magical Orb.zipReferences  https://www.youtube.com/watch?v=DpXPhGeCqus"
  },
  
  {
    "title": "Game View Auto Updater(에디터 모드에서 게임 뷰 자동으로 갱신)",
    "url": "/posts/unity-game-view-auto-updater/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, editor, csharp, utility",
    "date": "2021-06-30 22:00:00 +0900",
    





    "snippet": "Summary플레이 모드에 진입하지 않으면 게임 뷰는 GUI에 변화가 있을 때만 갱신됩니다.따라서 쉐이더를 통해 각종 애니메이션이나 효과를 만들고 마테리얼을 통해 적용해도에디터 모드에서는 이를 정상적으로 확인할 수 없습니다.이 애셋은 에디터 모드에서도 마테리얼 효과를 정상적으로 확인할 수 있게 합니다.How To Use      첨부된 Game-View-Auto-Updater.unitypackage 파일을 다운받습니다.        유니티 프로젝트가 켜진 상태로 해당 파일을 실행하여 프로젝트 내에 임포트합니다.        에..."
  },
  
  {
    "title": "유니티 - 게임 뷰를 강제로 업데이트하기",
    "url": "/posts/unity-update-game-view/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, memo",
    "date": "2021-06-30 21:00:00 +0900",
    





    "snippet": "방법1      플레이 모드에 진입하지 않고 게임 뷰에서 쉐이더 애니메이션을 확인하고 싶을 때 사용한다.        아무 게임오브젝트나 붙잡고 Dirty로 만들어주면 게임 뷰가 업데이트 된다.  EditorUtility.SetDirty(GameObject.FindObjectOfType&amp;lt;Transform&amp;gt;());  다음과 같은 Repaint 메소드들은 통하지 않는다.EditorWindow focused = EditorWindow.focusedWindow;focused.Repaint();UnityEdit..."
  },
  
  {
    "title": "Main Thread Dispatcher",
    "url": "/posts/unity-main-thread-dispatcher/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, mainthreaddispatcher",
    "date": "2021-06-30 04:04:00 +0900",
    





    "snippet": "메인 스레드 디스패처?유니티 엔진에서는 메인 스레드가 아닌 다른 스레드에서게임오브젝트, 트랜스폼 등 유니티 API에 접근할 수 없게 제한되어 있다.하지만 메인 스레드 디스패처를 사용하면 이 문제를 해결할 수 있다.동작 원리      메인 스레드 디스패처에는 동기화 큐(Queue)가 존재한다.        다른 스레드에서 유니티 API 작업이 필요할 경우, 메인 스레드 디스패처의 큐에 집어 넣는다.        메인 스레드 디스패처는 매 프레임마다 큐에서 작업을 꺼내어 메인 스레드 내에서 수행한다.        다른 스레드에서는..."
  },
  
  {
    "title": "간단한 앰플리파이 쉐이더 예제 모음",
    "url": "/posts/simple-amplify-shader-examples/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-06-27 04:24:00 +0900",
    





    "snippet": "Note  각 예제마다 있는 Copy &amp;amp; Paste 부분의 코드를 복사하고, 앰플리파이 쉐이더 에디터에 Ctrl + V로 붙여 넣어서 곧바로 해당 노드들을 생성할 수 있습니다.1. VertexScale Up and Down   Copy &amp;amp; Paste            http://paste.amplify.pt/view/raw/a358e6ec    Heartbeat   Copy &amp;amp; Paste            http://paste.amplify.pt/view/raw/e6f80d1c..."
  },
  
  {
    "title": "Process, Thread, ThreadPool, Task 개념 간단 정리",
    "url": "/posts/cs-process-thread-threadpool-task/",
    "categories": "C#, C# Threading",
    "tags": "csharp, process, thread, task",
    "date": "2021-06-25 21:21:00 +0900",
    





    "snippet": "Process      메모리에 적재되어 실행되는 프로그램        운영체제로부터 자원을 할당받아 수행되는 작업의 단위        Code, Data, Heap, Stack 메모리 공간을 독립적으로 갖는다.  Thread      프로세스의 자원을 사용하는 실행 흐름의 단위        프로세스의 Code, Data, Heap 영역을 공유한다.        각 스레드마다 Stack 영역만 독립적으로 갖는다.        컨텍스트 스위칭이 발생할 때 Stack 정보를 비롯해 간단한 정보만 저장하기 때문에, 프로세스의 컨텍스..."
  },
  
  {
    "title": "유니티 - Camera Depth, Sorting Layer, Sorting Group",
    "url": "/posts/unity-depth-sorting-layer-sorting-group/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-06-25 20:40:00 +0900",
    





    "snippet": "Camera Depth(Z)      카메라로부터의 거리        가까울수록 먼저 보인다.  Sorting Layer vs. Camera Depth      Sorting Layer가 Camera Depth보다 우선적으로 깊이를 결정한다.        Sorting Layer 설정이 같은 경우, Camera Depth가 깊이를 결정한다.  Sorting Layer      서로 다른 Sorting Layer의 경우, 인덱스의 값이 클수록(0 &amp;lt; 1 &amp;lt; 2 &amp;lt; …) 먼저 보인다.     ..."
  },
  
  {
    "title": "앰플리파이 쉐이더 입문자를 위한 60가지 노드 모음",
    "url": "/posts/amplify-shader-60-nodes-for-beginners/",
    "categories": "Unity Shader, Amplify Shader",
    "tags": "unity, csharp, shader, amplify",
    "date": "2021-06-24 01:23:00 +0900",
    





    "snippet": "목표  앰플리파이 쉐이더 그래프를 다루기 위해 필요한, 아주 기초적인 60가지 노드 익히기목차  프로퍼티(변수)          Int (0)      Float (1)      Vector2 (2)      Vector3 (3)      Vector4 (4)      Color (5)      Texture Sample (T)        상수          PI      Tau        정점 데이터          Vertex Position      World Position      Vertex Normal    ..."
  },
  
  {
    "title": "Black Hole &amp;amp; World Position Offset",
    "url": "/posts/unity-black-hole-effect-shadergraph/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-06-20 03:33:00 +0900",
    





    "snippet": "SummaryWorld Position Offset Shader  정점이 순차적으로 월드의 특정 좌표에 빨려 들어가는 쉐이더Black Hole Shader  영역 내의 색상을 왜곡하는 쉐이더PreviewWPO - Step 1 : 정점 좌표의 이동World Space의 좌표에 대해 계산해야 하지만,마스터 노드의 Vertex Position 입력은 Object Space여야 한다.따라서 두 가지 선택지가 있다.[1] World Space에서 계산하고 최종적으로 Object Space로 변환[2] 처음부터 Object Space로 ..."
  },
  
  {
    "title": "유니티 - 큰 성능 저하 없이 텍스쳐에 그림 그리기",
    "url": "/posts/unity-how-to-paint-texture/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, shorts",
    "date": "2021-06-19 17:17:00 +0900",
    





    "snippet": "텍스쳐의 특정 픽셀 색상 변경하기텍스쳐의 특정 픽셀 색상을 변경하는건 매우 간단하다.[1] 텍스쳐의 Read/Write Enabled를 체크한다.[2] 대상 마테리얼에서 텍스쳐를 가져온다.[3] SetPixel() 메소드로 원하는 픽셀의 색상을 변경한다.[4] Apply() 메소드로 적용한다.하지만 메모리에 적재된 텍스쳐를 저렇게 직접 수정하는건CPU 입장에서 매우 부담되는 일이므로 성능 저하가 막심하다.렌더 텍스쳐를 거쳐 색상 변경하기위와 같은 큰 성능 저하 없이 런타임에 텍스쳐 픽셀을 수정하려면,렌더 텍스쳐를 거쳐야 한다...."
  },
  
  {
    "title": "Texture Painter(텍스쳐에 그림 그리기)",
    "url": "/posts/unity-texture-painter/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-06-19 04:32:00 +0900",
    





    "snippet": "Summary  실시간으로 마우스 클릭, 드래그를 통해 게임 오브젝트의 텍스쳐에 그림 그리기How To Use그림 그려질 대상 게임오브젝트      알맞은 콜라이더를 넣는다.        Rito/PaintTexture 쉐이더로 생성한 마테리얼을 적용한다.        TexturePaintTarget 컴포넌트를 추가는다.  브러시      씬에 빈 게임오브젝트를 생성하고 TexturePaintBrush 컴포넌트를 추가는다.        Brush Size로 브러시의 크기를 조절할 수 있다.        Brush Textur..."
  },
  
  {
    "title": "Strategy Pattern(전략 패턴)",
    "url": "/posts/strategy-pattern/",
    "categories": "Algorithm, Design Pattern",
    "tags": "algorithm, pattern, csharp",
    "date": "2021-06-17 21:12:00 +0900",
    





    "snippet": "Strategy Pattern(전략 패턴)설명      행동 패턴(Behaviour Pattern)의 일종        알고리즘을 클래스화하여, 실행 중에 알고리즘(전략)을 통째로 교체하며 사용한다. (핵심)        if-else 또는 switch-case 구문을 통해 어떤 기준에 따라 분기로 작성하던 기능을 각각 클래스화시킨다.        베이스 클래스를 각각 상속받는 전략 클래스들과 이를 교체하며 사용하는 클래스로 이루어진다.        각 전략 클래스는 베이스 클래스를 통해 통일된 행동을 기반으로 구현해야 한다...."
  },
  
  {
    "title": "CIL 코드 뜯어보기",
    "url": "/posts/cs-memo-show-cil/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-06-15 20:00:00 +0900",
    





    "snippet": "1. 소스코드 컴파일  컴파일을 완료하고 .exe 또는 .dll 파일을 생성한다.2. 디스어셈블러 실행C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.8 Tools이런 경로로 들어가서ildasm.exe 파일을 찾아 실행한다.경로는 버전마다 조금씩 차이가 있다.3. 대상 어셈블리 열기파일 - 열기를 통해 앞서 컴파일 완료한 파일을 열어준다.4. CIL 코드 확인3에서 원하는 메소드를 찾아 더블클릭한다.주의사항  디스어셈블러에서 특정 어셈블리를 열어둔 상태에서는 ..."
  },
  
  {
    "title": "Jekyll 블로그 만들기 간단 메모",
    "url": "/posts/memo-init-jekyll-blog/",
    "categories": "Memo",
    "tags": "memo",
    "date": "2021-06-15 14:55:00 +0900",
    





    "snippet": "Start Jekyll Blog1. Ruby 설치  https://rubyinstaller.org/downloads/  2.7.32. Jekyll Bundler 설치  cmd 켰을 때 나오는 사용자 기본 경로에 설치gem install jekyll bundler3. 블로그용 깃헙 원격 리포 준비  리포 이름은 닉네임.github.io4. 로컬 리포 준비  원격 리포랑 연결git initgit add .git commit -m &quot;init&quot;git branch -M maingit remote add origin [..."
  },
  
  {
    "title": "LINUX CLI",
    "url": "/posts/memo-linux-cli/",
    "categories": "Memo",
    "tags": "memo, linux, ubuntu",
    "date": "2021-06-15 02:34:00 +0900",
    





    "snippet": "리눅스 설치1. Virtual Box + Ubuntu Server(CLI)  CLI : Command Line Interface  https://www.virtualbox.org/wiki/Downloads  https://ubuntu.com/download/server - Option 22. 구름 IDE (10GB 무료)  https://www.goorm.io/  대시보드 - 새 컨테이너 생성 - Blank  대시보드 이동 - 터미널 실행3. AWS Cloud9  https://aws.amazon.com/ko/cloud9/4...."
  },
  
  {
    "title": "유니티 - 스크립트로 콘솔 내용 지우기",
    "url": "/posts/unity-clear-console-through-script/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, csharp",
    "date": "2021-06-14 02:22:00 +0900",
    





    "snippet": "private static MethodInfo clearMethodInfo;private static void ClearLog(){    if (clearMethodInfo == null)    {        var assembly = Assembly.GetAssembly(typeof(UnityEditor.Editor));        var type = assembly.GetType(&quot;UnityEditor.LogEntries&quot;);        clearMethodInfo = type.GetMethod(&q..."
  },
  
  {
    "title": "유니티 - 에디터 윈도우 관련 유용한 코드 모음",
    "url": "/posts/unity-editor-window-codes/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, editor",
    "date": "2021-06-14 01:50:00 +0900",
    





    "snippet": "Enum - EditorWindowType[Flags]private enum EditorWindowType{    Scene = 1,    Game  = 2,    Inspector = 4,    Hierarchy = 8,    Project   = 16,    Console   = 32}특정 윈도우에 포커스하기private static void FocusOnWindow(EditorWindowType windowType){    EditorApplication.ExecuteMenuItem(&quot;Window/General/..."
  },
  
  {
    "title": "유니티 - 커스텀 에디터(인스펙터)의 스크롤바를 고려한 너비 구하기",
    "url": "/posts/unity-editor-view-width-considering-scroll/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, csharp",
    "date": "2021-06-13 23:33:00 +0900",
    





    "snippet": "Note커스텀 에디터에서 EditorGUIUtility.currentViewWidth를 통해 현재 에디터의 너비를 구할 수 있지만,위처럼 컴포넌트 창이 상하로 길어져 우측에 스크롤바가 생기는 경우스크롤바가 컨트롤들을 가림에도 불구하고, currentViewWidth는 스크롤바를 포함한 너비를 알려주며스크롤바를 제외한 너비를 구하는 API가 제공되지 않는다.심지어 스크롤바의 존재 여부조차 스크립트를 통해서는 알 수 없다.따라서 편법을 통해 구해야 한다.How toLayout API들을 통해 만들어진 Rect는 항상 에디터창의 우..."
  },
  
  {
    "title": "Singleton Pattern(싱글톤 패턴)",
    "url": "/posts/singleton-pattern/",
    "categories": "Algorithm, Design Pattern",
    "tags": "algorithm, pattern, csharp",
    "date": "2021-06-11 17:17:00 +0900",
    





    "snippet": "Singleton Pattern특징  정적 참조로부터 인스턴스 참조를 가져올 수 있다.  특정 클래스에 단 한 개의 객체만 존재하도록 보장할 수 있다.사용처  프로그램 내에 반드시 하나만 존재해야 하는 클래스고려사항  싱글톤 객체 생성 타이밍을 고려해야 한다. (정적 or 동적)  기본적으로 스레드 안전하지 않으므로, 추가적인 처리가 필요하다.싱글톤 인스턴스를 통한 호출(공통)class SingletonTest{    public static void Method()    {        // 클래스명.Instance.멤버참조..."
  },
  
  {
    "title": "유니티 - 마우스 커서가 UI 위에 있는지 검사하는 간단한 코드",
    "url": "/posts/unity-check-cursor-over-ui/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-06-10 02:22:00 +0900",
    





    "snippet": "private static bool IsPointerOverUI()    =&amp;gt; UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();"
  },
  
  {
    "title": "유니티 - 이벤트 함수는 어떻게 실행되는 것일까?",
    "url": "/posts/unity-event-functions/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-06-06 05:05:00 +0900",
    





    "snippet": "Unity Event Functions유니티엔진에서 ‘스크립트’를 작성한다고 하면, 보통 MonoBahaviour를 상속받는 클래스의 스크립트를 작성하는 것을 떠올릴 것이다.그리고 자연스럽게 이 클래스 내에 Awake(), Start(), Update() 등의 메소드를 작성하게 된다.심지어 비주얼 스튜디오 같은 개발 환경에서는 이런 메소드들에 대해 자동 완성도 해주고, 메소드 위에는 Unity 메시지라는 글자도 띄워준다.이런 메소드들은 ‘Unity Event Function’, ‘Unity Message’ 또는 ‘Magic M..."
  },
  
  {
    "title": ".NET 환경의 컴파일 과정 - CLR, CIL, JIT, AOT",
    "url": "/posts/cs-dotnet-compile/",
    "categories": "C#, C# Study",
    "tags": "dotnet, clr, cil, jit, aot",
    "date": "2021-06-06 04:43:00 +0900",
    





    "snippet": ".NET 환경의 컴파일 과정예전의 C, C++의 경우 개별 환경이 프로그램의 실행 시간에 영향을 미치는 문제가 있었다.하지만 Java가 나오면서 컴파일된 바이트코드는 윈도우, 리눅스, 그 어떤 실행환경이든 JVM만 실행 가능하다면 실행할 수 있다는 장점을 통해 인기를 끌었고,마이크로소프트는 이를 이용해 기존 문제를 해결할 수 있도록 .NET 환경에 가상 머신을 만들어서.NET 환경의 언어로 개발된 IL(Intermediate Language, 중간 언어) 코드들은 .NET Framework가 설치된 어떠한 환경에서도 실행할 수..."
  },
  
  {
    "title": "Method Chaining &amp; Generic(메소드 체인 패턴)",
    "url": "/posts/method-chaning-pattern/",
    "categories": "Algorithm, Design Pattern",
    "tags": "algorithm, pattern, csharp",
    "date": "2021-05-28 22:02:00 +0900",
    





    "snippet": "메소드 체이닝 패턴특징  메소드가 객체를 반환하는 형태로 작성한다.  문장을 마치지 않고 메소드 호출을 이어나갈 수 있다.  가독성을 향상시킬 수 있다.주의사항  한 문장에 여러번의 메소드 호출이 존재할 수 있으므로, 에러가 발생할 경우 정확한 지점을 한 번에 찾기 힘들다.  C# 구조체의 메소드를 체이닝으로 구현할 경우, 매 번 구조체 전체의 복제가 발생하므로 바람직하지 않다.예시class Box{    private float width;    private float height;    public Box SetWidth..."
  },
  
  {
    "title": "유니티 - FBX Exporter",
    "url": "/posts/unity-fbx-exporter/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-05-27 17:02:00 +0900",
    





    "snippet": "Summary  유니티 내에 존재하는 메시를 .fbx 파일로 추출해주는 애셋Import      [Window] - [Package Manager]        좌측 상단 [Unity Registry] 설정        FBX Exporter 검색 및 Install  How to Use      하이라키에서 내보낼 게임오브젝트에 우클릭 후 Export To FBX 클릭        Export Name, Export Path 설정 후 Export  Old Version  https://github.com/unity3d-jp/F..."
  },
  
  {
    "title": "유니티 - 에디터 GUI 이벤트 모음",
    "url": "/posts/unity-editor-gui-events/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-05-25 02:22:00 +0900",
    





    "snippet": "Mouse Over Control  특정 컨트롤에 마우스가 위치해 있는지 확인[1] Layout 요소가 아닌 경우Rect rect = /* Set Rect */;EditorGUI.LabelField(rect, &quot;Label&quot;); // Draw Field Controlbool mouseOver = rect.Contains(Event.current.mousePosition);[2] Layout 요소인 경우EditorGUILayout.TextField(&quot;Text&quot;);bool mouseOver = G..."
  },
  
  {
    "title": "유니티 - Material Property Block을 통해 프로퍼티 값 변경하기",
    "url": "/posts/unity-material-property-block/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimization, material, batch",
    "date": "2021-05-22 18:00:00 +0900",
    





    "snippet": "드로우 콜과 배칭의 개념  포스트 : 드로우 콜과 배칭마테리얼 프로퍼티 값 변경하기MeshRenderer.material.Set~ 메소드를 통해스크립트에서 마테리얼 특정 프로퍼티의 값을 실시간으로 변경할 수 있다.하지만 이렇게 .material에 접근하여 프로퍼티를 수정하면이런식으로 마테리얼이 개별 인스턴스로 복제되어, 배칭이 깨지게 된다.(.material에 접근하기만 해도 바로 개별 인스턴스가 생성된다.)이를 방지할 수 있는 것이 Material Property Block, GPU Instancing이다.Material P..."
  },
  
  {
    "title": "Pivot Editor(메시의 피벗 위치 수정)",
    "url": "/posts/unity-pivot-editor/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, editor, csharp, utility",
    "date": "2021-05-20 15:00:00 +0900",
    





    "snippet": "Summary  메시의 피벗 위치를 직접 수정할 수 있는 기능을 제공합니다.  메시의 위치, 회전, 크기를 직접 변경할 수 있습니다.PreviewInspectorScenePreview(GIF)How To UsePivot Editor 컴포넌트 추가      Mesh Filter 컴포넌트를 우클릭하고 Edit Pivot을 클릭합니다.        게임오브젝트에 Mesh Filter, Mesh Renderer 컴포넌트가 모두 존재해야 합니다.  Edit/Cancel 버튼  피벗 수정 기능을 활성화/비활성화합니다.Options    ..."
  },
  
  {
    "title": "Position Fixer",
    "url": "/posts/unity-position-fixer/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-05-19 20:00:00 +0900",
    





    "snippet": "Summary  부모 게임오브젝트의 이동에 영향받지 않고 트랜스폼 위치를 고정시키는 컴포넌트How To Use  위치를 고정/해제할 게임오브젝트에 컴포넌트로 넣는다.  인스펙터에서 Activated를 체크하거나 스페이스바를 눌러 기능을 활성화한다.Download  PositionFixer.zipSource Code  https://github.com/rito15/Unity_Toys   .  using System;using System.Collections;using System.Collections.Generic;using ..."
  },
  
  {
    "title": "유니티 - 각종 윈도우 새로고침하기",
    "url": "/posts/unity-editor-refresh-windows/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, csharp",
    "date": "2021-05-19 01:00:00 +0900",
    





    "snippet": "커스텀 에디터 - 인스펙터뷰  Editor.Repaint()// 해당 CustomEditor 내에서 호출this.Repaint();커스텀 에디터 윈도우  EditorWindow.Repaint()this.Repaint();씬뷰인스펙터의 변경사항이 씬뷰에 곧바로 적용되지 않고씬뷰에 마우스를 올리거나 키보드 입력이 있어야 적용될 경우,SceneView.RepaintAll()을 호출하면 된다.커스텀 에디터에서 인스펙터와 씬뷰의 동기화가 필요한 경우OnInspectorGUI() 내에서 호출하면 된다.프로젝트뷰프로젝트 내의 파일 변경사항..."
  },
  
  {
    "title": "유니티 - GUI 스타일 지정하기",
    "url": "/posts/unity-editor-gui-style/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-05-18 02:02:00 +0900",
    





    "snippet": "인라인 방식으로 스타일 설정하기  GUI.___ 프로퍼티 값들을 수정하고 돌려놓기// OnInspectorGUIvar oldBgColor = GUI.backgroundColor;GUI.backgroundColor = Color.red;// &amp;lt;- Draw GUIsGUI.backgroundColor = oldBgColor;GUIStyle 객체 이용하기      GUI 컨트롤을 생성하는 메소드의 매개변수로 GUIStyle 객체를 넣어서 스타일을 지정할 수 있다.        미리 만들어진 스타일들을 그대로 사용하거나,G..."
  },
  
  {
    "title": "유니티 - 컴포넌트를 인스펙터 최상단에 올리기",
    "url": "/posts/unity-put-component-on-top/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, csharp, shorts",
    "date": "2021-05-17 21:12:00 +0900",
    





    "snippet": "Memo/// &amp;lt;summary&amp;gt; 컴포넌트를 최상단에 올리기 &amp;lt;/summary&amp;gt;[System.Diagnostics.Conditional(&quot;UNITY_EDITOR&quot;)]private static void PutComponentOnTop(Component component){    for (int i = 0; i &amp;lt; 100 &amp;amp;&amp;amp; UnityEditorInternal.ComponentUtility.MoveComponentUp(co..."
  },
  
  {
    "title": "유니티 - Obj Exporter(메시를 OBJ 파일로 저장하기)",
    "url": "/posts/unity-obj-exporter/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-05-17 05:17:00 +0900",
    





    "snippet": "Source Code   ObjExporter.cs  #if UNITY_EDITORusing System;using System.Text;using System.Collections;using System.Collections.Generic;using UnityEngine;using System.IO;namespace Rito{    // http://wiki.unity3d.com/index.php?title=ObjExporter    public static class ObjExporter    {        public ..."
  },
  
  {
    "title": "유니티 - Graphic Raycaster 마우스 이벤트 예제",
    "url": "/posts/unity-graphic-raycaster-mouse-event-examples/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui, event",
    "date": "2021-05-16 03:21:00 +0900",
    





    "snippet": "PreviewEnter, Exit, DownDragDrag(Grid)Source Code   Icon.cs  using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Icon : MonoBehaviour{    private Image image;    private int siblingIndex;    private static readonly Color Defau..."
  },
  
  {
    "title": "실수를 스트링으로 변환할 때 포맷 지정하기",
    "url": "/posts/cpp-float-to-string-format/",
    "categories": "Memo, Cpp Memo",
    "tags": "cpp",
    "date": "2021-05-16 01:33:00 +0900",
    





    "snippet": "Headers#include &amp;lt;iostream&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;iomanip&amp;gt;Cout Format  출력하기 전에 std::cout &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision() 호출// 소수 첫째 자리에서 반올림std::cout &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(0);st..."
  },
  
  {
    "title": "Magical Orb",
    "url": "/posts/unity-urp-sg-magical-orb/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-05-14 02:00:00 +0900",
    





    "snippet": "Summary      꿀렁이며 움직이는 구체 쉐이더        Scene Color 노드를 사용하므로, Render Pipeline Asset에서 Opaque Texture에 체크해야 한다.        마스터 노드의 Surface를 Transparent로 설정해야 한다.  PreviewOptions            프로퍼티      설명                  Pattern Texture      구체 표면의 패턴 텍스쳐(반복 연결되어야 함)              Tiling X      텍스쳐의 X 타일링 ..."
  },
  
  {
    "title": "유니티 - UI(RectTransform)의 스크린 픽셀 크기 계산하기",
    "url": "/posts/unity-calculate-ui-pixel-size/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-05-10 18:00:00 +0900",
    





    "snippet": "Note모든 UGUI 요소는 RectTransform을 통해 크기를 결정한다.그리고 RectTransform.rect로 크기를 참조할 수 있다.그런데 이 크기는 해상도가 변해도 항상 같은 값을 반환한다.따라서 해상도를 기반으로 하는 드래그 등의 기능을 구현할 때마우스 변위를 해상도 값으로 가져오고, 이를 RectTransform에 적용하면해상도가 달라졌을 때 원치 않는 동작을 하게 된다.CanvasScaler를 이용하면 현재 스크린에 따른 실제 픽셀 크기를 계산할 수 있다.크기 계산  CanvasScaler의 [UI Scale..."
  },
  
  {
    "title": "C# unsafe와 fixed 구문",
    "url": "/posts/cs-unsafe-and-fixed/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-05-10 14:14:00 +0900",
    





    "snippet": "safe(안전한 코드)      C#에서 일반적인 코드는 “확인할 수 있는 안전한 코드”이다.        .NET에서 코드가 안전한지 확인할 수 있음을 의미한다.        메모리를 직접 할당하지 않고, 관리형 개체를 만든다.  unsafe      unsafe 컨텍스트 내에서는 ‘확인할 수 없는 안전하지 않은 코드’를 작성할 수 있다.        안전하지 않은 코드란, 위험한 것이 아니라 CLR에서 안전을 확인할 수 없다는 것을 의미한다.  허용되는 것들  포인터 사용  메모리 블록 할당 및 해제  함수 포인터를 사용하..."
  },
  
  {
    "title": "C# - 스트링 포맷 정리",
    "url": "/posts/cs-string-format/",
    "categories": "C#, C# Memo",
    "tags": "csharp, tostring",
    "date": "2021-05-09 21:00:00 +0900",
    





    "snippet": "NOTE  , : 스트링의 범위(공간) 설정  : : 출력 포맷 설정좌우 정렬$&quot;{value, 10}&quot;  10칸 범위 내에서 우측 정렬$&quot;{value, -10}&quot;  10칸 범위 내에서 좌측 정렬숫자 왼쪽에 공백 삽입하기$&quot;{value :   0}&quot;  :, 0 사이의 공백 크기만큼 고정된 공백을 삽입  값의 왼쪽에 공백 3칸을 항상 삽입  오른쪽은 설정 불가자리수 설정$&quot;{value :000}&quot;  세 번째 자리까지 채워서 표현(빈 칸은 0으로 채움)  실수일..."
  },
  
  {
    "title": "C# 윈폼 - 마우스 이벤트를 통과시킬 수 있는 컨트롤 만들기",
    "url": "/posts/cs-winform-pass-through-mouse-events/",
    "categories": "C#, C# Winform",
    "tags": "",
    "date": "2021-05-09 01:30:00 +0900",
    





    "snippet": "목표  마우스 이벤트를 모두 무시할 수 있는 컨트롤(버튼, 레이블 등) 만들기방법      특정 컨트롤 클래스(Button, Label, …)를 상속받는 클래스를 작성한다.        아래와 같이 프로퍼티와 메소드를 작성한다.  public bool Ignored { get; set; } = false;protected override void WndProc(ref Message m){    const int WM_NCHITTEST = 0x0084;    const int HTTRANSPARENT = (-1);    if (..."
  },
  
  {
    "title": "C# 윈폼 - 중복 실행 방지",
    "url": "/posts/cs-winform-prevent-duplication/",
    "categories": "C#, C# Winform",
    "tags": "",
    "date": "2021-05-06 02:02:00 +0900",
    





    "snippet": "Memo  Program.cs에서 Main() 메소드 지우고 아래 내용 복붙하기/// &amp;lt;summary&amp;gt;/// 해당 응용 프로그램의 주 진입점입니다./// &amp;lt;/summary&amp;gt;[STAThread]static void Main(){    if (!IsDuplicated())        RunApplication();}// 이미 실행 중인 프로세스(중복 프로세스)가 있는지 확인private static bool IsDuplicated(){    try    {        int p..."
  },
  
  {
    "title": "C# 윈폼 - Notify Icon 사용하기",
    "url": "/posts/cs-winform-notifyicon/",
    "categories": "C#, C# Winform",
    "tags": "csharp, winform",
    "date": "2021-05-06 02:02:00 +0900",
    





    "snippet": "Memo1. 도구  NotifyIcon 추가  ContextMenuStrip 추가2. 속성  Form - Icon에 .ico 아이콘 파일 등록  NotifyIcon - Icon에 아이콘 등록(안하면 컨텍스트 안생김)  NotifyIcon - ContextMenuStrip 연결3. 필드, 메소드 추가//FormClosing 이벤트로 종료 가능 여부private bool closeAllowed = false;private void ShowForm(){    // 폼 등장    this.Show();    //창의 속성을 최소화-&..."
  },
  
  {
    "title": "Git - 저장소 구조",
    "url": "/posts/memo-git-repos/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2021-05-03 17:00:00 +0900",
    





    "snippet": "1. 로컬 저장소[1] Working Directory  작업 디렉토리 : 윈도우 내 폴더  git add 명령어를 통해 변경된 파일들을 Staging Area로 옮길 수 있다.[2] Staging Area  커밋할 대상들을 저장하는 임시 저장소  파일 변경사항 스냅샷을 안전하게 보관하지는 않는다.  git commit 명령어를 통해 스테이징 영역 내의 파일들을 .git Directory로 옮길 수 있다.[3] .git Directory (History)  커밋 히스토리를 저장한다.  커밋 버전별로 내용을 관리할 수 있다.  ..."
  },
  
  {
    "title": "유니티 - 커스텀 에디터로 인스펙터에 Private 필드 나타내기",
    "url": "/posts/unity-editor-show-private-fields/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-04-29 20:30:00 +0900",
    





    "snippet": "Memo커스텀 에디터를 통해서 private 필드를 인스펙터에 표시하려면 일단 두 가지 방법이 있다.1. 내부 클래스로 작성커스텀 에디터 클래스를 대상 모노비헤이비어 클래스의 내부에 작성하면 private 필드에도 접근할 수 있다.public partial class RadialMenu : MonoBehaviour{    [CustomEditor(typeof(RadialMenu))]    public class RadialMenuEditor : UnityEditor.Editor    {        private RadialM..."
  },
  
  {
    "title": "유니티 - Radial Menu 만들기",
    "url": "/posts/unity-study-radial-menu/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-04-26 18:00:00 +0900",
    





    "snippet": "목표  극좌표계를 이용하여 원형 분포 형태의 메뉴 UI 만들기Preview직교 좌표계  Cartesian Coordinate System유니티2D에서 사용하는 좌표계는 x, y 축으로 이루어진 직교 좌표계이다.데카르트 좌표계라고도 하며, x, y 값을 통해 좌표를 표현한다.극좌표계  Polar Coordinate System직교 좌표계와는 달리, 거리(radius)와 각도(angle)를 통해 특정 좌표를 표현한다.이 때 거리는 중심으로부터의 거리, 각도는 직교 좌표계의 +X 축으로부터의 각도를 의미한다.좌표가 중심을 기준으로 ..."
  },
  
  {
    "title": "브레즌햄(픽셀에 직선 그리기) 알고리즘",
    "url": "/posts/bresenham-algorithm/",
    "categories": "Algorithm, Algorithms",
    "tags": "algorithm, csharp",
    "date": "2021-04-25 17:32:00 +0900",
    





    "snippet": "Summary직선을 그릴 때 직선 위의 점들은 실수 값을 가질 수밖에 없다.그래서 불연속 정수 값만을 갖는 픽셀에 직선을 그릴 때는실수 값의 소수점을 버리거나 반올림하여 정수로 변환해야 하는데,브레즌햄 알고리즘은 실수 연산 없이 정수 연산만으로 직선을 그릴 수 있게 해준다.Details2가지 경우로 나눈다.  기울기 절댓값이 1 미만인 경우  기울기 절댓값이 1 이상인 경우1번의 경우에는 x 좌표를 1씩 증가 또는 감소시키며 해당하는 y 좌표를 구하고,2번의 경우에는 y 좌표를 1씩 증가 또는 감소시키며 해당하는 x 좌표를 구..."
  },
  
  {
    "title": "유니티 - Debug.Log()에 색상 넣기",
    "url": "/posts/unity-memo-color-debug-log/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, shorts",
    "date": "2021-04-25 17:10:00 +0900",
    





    "snippet": "Memo  &amp;lt;color=&amp;gt;&amp;lt;/color&amp;gt; 태그를 사용하여 로그 메시지에 색상을 넣을 수 있다.  color= 뒤에는 색상 이름 또는 HTML 색상코드를 입력한다.Debug.Log(&quot;Default&quot;);Debug.Log(&quot;&amp;lt;color=white&amp;gt;White&amp;lt;/color&amp;gt;&quot;);Debug.Log(&quot;&amp;lt;color=grey&amp;gt;Grey&amp;lt;/color&amp;gt;&q..."
  },
  
  {
    "title": "Drag and Drop Recorder",
    "url": "/posts/unity-toy-drag-and-drop-recorder/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-04-19 21:00:00 +0900",
    





    "snippet": "Summary  드래그 앤 드롭으로 게임오브젝트를 커서를 따라 이동시킨다.  이동 경로를 기록하고, 반복재생할 수 있다.How To Use  빈 게임오브젝트에 DDRecorder 컴포넌트를 추가한다.  드래그 앤 드롭으로 이동시킬 게임오브젝트에 콜라이더와 DDTarget 컴포넌트를 추가한다.  DDRecorder 컴포넌트의 Replay Target 필드에 반복 재생시킬 게임오브젝트를 등록한다.  스페이스바를 누를 때마다 등록된 경로대로 타겟 게임오브젝트가 이동한다.PreviewDownload  Drag and Drop Reco..."
  },
  
  {
    "title": "유니티 - RPG Inventory System(RPG 게임 인벤토리 만들기)",
    "url": "/posts/unity-study-rpg-inventory/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-04-15 22:00:00 +0900",
    





    "snippet": "개요  RPG 게임에서 사용할 수 있는 기본적인 인벤토리를 구현한다.구현할 기능  아이템 추가(습득)  아이템 제거(버리기)  아이템 사용  아이템 이동  슬롯 하이라이트  아이템 툴팁  아이템 버리기 팝업  아이템 개수 나누기 팝업  인벤토리 빈칸 채우기  인벤토리 정렬  아이템 필터링클래스 구성1. 인벤토리  Inventory : 전체 아이템들을 관리하고, 인벤토리 내부의 실질적 동작들을 담당한다.2. 아이템  Item : 인벤토리의 각 슬롯에 들어가는 실제 아이템. 각각의 아이템이 개별적으로 갖는 데이터들을 보관한다.  ..."
  },
  
  {
    "title": "Quick Sort(빠른 정렬)",
    "url": "/posts/algorithm-quick-sort/",
    "categories": "Algorithm, Sort Algorithm",
    "tags": "algorithm, csharp",
    "date": "2021-04-07 22:00:00 +0900",
    





    "snippet": "Summary            시간복잡도      평균 \\(O(n log n)\\), 최악 \\(O(n^2)\\)              공간복잡도      \\(O(n)\\)              정렬 특징      불안정 정렬      특징  분할 정복  재귀Details메소드 구성QuickSort(arr, left, right)  배열의 left ~ right 인덱스 내에서만 정렬을 수행한다.Partition(arr, left, right)  배열의 left ~ right 인덱스 내에서 피벗을 선정한다.  내부적으로 정렬을 ..."
  },
  
  {
    "title": "O(logn) 거듭제곱 알고리즘",
    "url": "/posts/algorithm-pow/",
    "categories": "Algorithm, Algorithms",
    "tags": "algorithm, csharp",
    "date": "2021-04-06 18:00:00 +0900",
    





    "snippet": "Summary      일반적으로 \\(O(n)\\) 시간복잡도로 수행하는 거듭제곱 계산을 \\(O(log_{2}n)\\) 의 시간복잡도로 수행할 수 있는 알고리즘        2진수 연산을 이용한다.  Details\\(a^n\\)을 계산하는 가장 쉬운 방법은 \\(a\\)를 \\(n\\) 번 곱하는 것이다.예를 들어 \\(4^9\\)을 구하려면 \\(4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4\\)를 계산하면 된다.하지만 이렇게 되면 \\(n - 1\\) 번의 곱셈을 수행하므로 ..."
  },
  
  {
    "title": "유니티 - 멀티스레딩과 Job의 활용",
    "url": "/posts/unity-study-multithread-job/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, multithread, job",
    "date": "2021-04-04 22:00:00 +0900",
    





    "snippet": "유니티에서의 멀티스레딩유니티엔진에서는 기본적으로 모든 CPU 연산이 메인 스레드에서 이루어진다.그렇다고 다중 스레드를 사용할 수 없다는 것은 아니지만메인 스레드가 아닌 다른 스레드에서 유니티의 메인 로직에 접근할 수 없도록 막혀있다.다시 말해, 다른 스레드에서는 게임오브젝트, 컴포넌트 등에 접근하면 에러가 발생한다.예를 들어private async void TaskTest(){    await Task.Run(() =&amp;gt;    {        transform.Translate(1f, 0f, 0f);    });}이..."
  },
  
  {
    "title": "파티클 시스템 예제 - 11 - Sword Effect",
    "url": "/posts/unity-particle-system-example-11-sword-effect/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-30 23:23:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 하이라키 구성  2. Glow 이펙트  3. Sparkle 이펙트  4. Aura 이펙트  5. 결과Preview목표  검 모델링에 부착하여 사용할 수 있는 이펙트(무기 강화 이펙트) 만들기준비물  검 모델링          https://assetstore.unity.com/packages/3d/props/weapons/free-low-poly-swords-189978        Sparkle, PointGlow 텍스쳐를 사용하는 Additive 마테리얼          Sparkle_Point..."
  },
  
  {
    "title": "Static Readonly vs. Const",
    "url": "/posts/memo-cs-static-readonly-vs-const/",
    "categories": "C#, C# Grammar",
    "tags": "csharp",
    "date": "2021-03-30 00:50:00 +0900",
    





    "snippet": "공통점  런타임에 값을 변경할 수 없다.차이점Static Readonly      필드 선언문 또는 정적 생성자에서만 값을 초기화할 수 있다.        값을 초기화하지 않으면 해당 타입의 기본값으로 초기화된다.        런타임 초기에 값이 고정된다.        값이 정해지면 변하지 않지만, 결국 변수이기 때문에 참조 오버헤드가 발생한다.  Const      필드 선언문에서만 값을 초기화할 수 있다.        값을 초기화해야만 한다.        컴파일 타임에 값이 고정된다.        리터럴처럼 사용될 수 있다..."
  },
  
  {
    "title": "유니티 - Voxel System(마인크래프트 구현하기) [TODO]",
    "url": "/posts/unity-study-voxel/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-03-26 20:40:00 +0900",
    





    "snippet": "목차  목표  1. 복셀 기본  2. 청크와 맵 데이터  3. 텍스쳐 입히기  4. 월드에서 청크 생성 및 관리하기  5. 지형 만들기  6. 캐릭터 컨트롤러 만들기  목표  유튜브 강좌를 따라가며 구현한다.유니티엔진에서 마인크래프트와 같은 복셀 시스템을 구현한다.모든 맵과 사물은 큐브 형태를 띠고 있으며, 생성하거나 파괴할 수 있다.각각의 큐브를 개별 오브젝트로 렌더링할 경우 부하가 굉장히 크기 때문에,일정 영역의 큐브들을 모아 하나의 청크(Chunk)이자 하나의 메시로 관리하는 것이 핵심이다.1. 복셀 기본큐브의 정점 데이..."
  },
  
  {
    "title": "C# - Prime Number(소수)",
    "url": "/posts/memo-cs-prime-number/",
    "categories": "C#, C# Memo",
    "tags": "csharp",
    "date": "2021-03-26 18:12:00 +0900",
    





    "snippet": "Memo1. 소수인지 확인하기/// &amp;lt;summary&amp;gt; 지정한 수가 소수인지 확인 &amp;lt;/summary&amp;gt;public static bool IsPrime(int value){    bool isEvenNumber = (value % 2) == 0;    // 짝수일 경우 2만 소수    if (isEvenNumber) return value == 2;    // 1은 소수 아님    if (value == 1) return false;    // 제곱근까지만 확인    int sqrt..."
  },
  
  {
    "title": "Cloaking(Refraction)",
    "url": "/posts/unity-urp-sg-cloaking/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-03-25 20:40:00 +0900",
    





    "snippet": "Summary      뒤의 풍경을 왜곡시켜 보여주는 클로킹 쉐이더        Render Pipeline Asset에서 Opaque Texture에 체크해야 한다.        Opaque Texture를 사용할 때는 쉐이더그래프의 마스터 노드 Surface를 Transparent로 설정해야 한다.  PreviewOptions            프로퍼티      설명                  Normal Map      노멀맵 텍스쳐(없을 경우 기본 노멀 벡터 사용)              Refraction    ..."
  },
  
  {
    "title": "노멀맵에서 노멀 벡터 추출하기",
    "url": "/posts/unity-urp-sg-memo-normal-map/",
    "categories": "Unity Shader, URP Shader Graph Memo",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-03-25 17:00:00 +0900",
    





    "snippet": "Memo      Tangent, Bitangent, Normal Vector로 이루어진 3x3 행렬과 샘플링된 노멀맵 벡터를 곱해줌으로써, 노멀맵으로부터 노멀 벡터를 추출하여 사용할 수 있다.        행렬을 만들 때 행벡터를 조립하여 만들지, 열벡터를 조립하여 만들지 여부에 주의해야 한다.        행렬과 벡터를 곱할 때 벡터가 앞에 나오면 행벡터, 뒤에 나오면 열벡터로 사용됨에 주의해야 한다.        T, B, N 벡터의 공간을 반드시 일치시켜줘야 한다.        각 벡터들의 공간은 노멀맵의 사용 대상에 ..."
  },
  
  {
    "title": "Directional Dissolve (2 Color)",
    "url": "/posts/unity-urp-sg-directional-dissolve/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-03-25 00:00:00 +0900",
    





    "snippet": "Summary      디졸브 방향을 직접 지정할 수 있는 디졸브 쉐이더        디졸브 효과 색상 2가지를 지정할 수 있다.        포스트 프로세싱 Bloom 효과가 반드시 필요하다.  PreviewOptions            프로퍼티      설명                  Main Texture      메인 텍스쳐              Tint Color      메인 텍스쳐에 곱할 색상              Color A      디졸브 첫 번째 영역의 색상              Color B ..."
  },
  
  {
    "title": "파티클 시스템 예제 - 10 - Magic Circle",
    "url": "/posts/unity-particle-system-example-10-magic-circle/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-23 17:12:00 +0900",
    





    "snippet": "목차  목표  준비물  1. Magic Circle 이펙트  2. Circle Loop 이펙트  3. Dust 이펙트  4. Burn 이펙트  5. 다양한 연출 효과Preview목표  예쁜 마법진 이펙트 만들기  Trail 활용하기  Duration, Delay 활용하여 다양한 연출 효과 만들기준비물MagicCircle_Resources.zip      텍스쳐 : 마법진, Point, Trail        Trail 텍스쳐는 다양한 텍스쳐들을 사용하여 서로 다른 효과를 낼 수 있다.          Default-Partic..."
  },
  
  {
    "title": "파티클 시스템 예제 - 09 - Rainfall",
    "url": "/posts/unity-particle-system-example-09-rainfall/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-23 17:10:00 +0900",
    





    "snippet": "목차  목표  준비물  씬 준비  1. Rainfall 이펙트  2. Splash 이펙트  3. Ripple 이펙트  4. 결과Preview[1][2]목표      비내리는 이펙트 만들기        빗줄기가 바닥에 충돌했을 때 물 튀기는 이펙트, 파문이 번져나가는 이펙트 만들기  준비물Rainfall_Resources.zip  빗줄기에 사용할 Droplet 텍스쳐          좌우 크기를 많이 줄여서 길쭉하게 사용하기 때문에 무엇이든 상관 없다.      기본값인 Default-Particle System도 가능     ..."
  },
  
  {
    "title": "유니티 - 베지어 곡선(Bezier Curve)",
    "url": "/posts/unity-study-bezier-curve/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, curve",
    "date": "2021-03-20 19:19:00 +0900",
    





    "snippet": "베지어 곡선  점과 점 사이의 선형 보간(Lerp, Linear interpolation)을 이용해 그려내는 곡선1차 베지어 곡선      Linear Curve        2개의 점        단순히 두 점 사이의 선형 보간을 통해, 직선을 그린다.  2차 베지어 곡선      Quadratic Curve        3개의 점 P0, P1, P2        Lerp(P0, P1, t)를 통해 보간된 지점 P01을 구한다.        Lerp(P1, P2, t)를 통해 보간된 지점 P02를 구한다.        P01..."
  },
  
  {
    "title": "유니티 - 트랜스폼과 방향벡터의 회전",
    "url": "/posts/unity-memo-rotation/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, rotation",
    "date": "2021-03-19 17:08:00 +0900",
    





    "snippet": "Memo유니티엔진에서의 회전  각 축에 회전이 적용되는 순서는 Y축 -&amp;gt; X축 -&amp;gt; Z축오일러 회전 값을 변경하여 회전시킬 때트랜스폼 오일러 회전 벡터의 X, Y, Z 값 중 회전시키려는 축을 제외하고 모두 0이라면(예 : X축으로 회전시키려는데 (34f, 0f, 0f)인 상태)해당 축의 오일러 값만 변경시키면 다른 축에 영향을 받지 않고 정상적으로 회전할 수 있다.정확히는, 유니티엔진의 회전 순서에 따라Z축 회전일 경우 X, Y 오일러 값에 상관 없이 회전이 가능하고X축 회전일 경우 Z 값이 0이 아..."
  },
  
  {
    "title": "파티클 시스템 예제 - 08 - Meteor Swarm [TODO]",
    "url": "/posts/unity-particle-system-example-08-meteor-swarm/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-16 17:10:00 +0900",
    





    "snippet": "Preview"
  },
  
  {
    "title": "파티클 시스템 예제 - 07 - Fireworks",
    "url": "/posts/unity-particle-system-example-07-fireworks/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-16 17:10:00 +0900",
    





    "snippet": "목차  목표  준비물  1. Fireworks 이펙트  2. SubEmitter - Birth  3. SubEmitter - Death  4. SubEmitter - Death Flash  5. 완성Preview목표      서브 이미터 모듈 이해하기        불꽃놀이 이펙트 완성하기  준비물  동그란 텍스쳐와 Additive 마테리얼1. Fireworks 이펙트불꽃을 하늘로 쏘아올리는, 간단한 형태의 이펙트를 우선 제작한다.준비      하이라키 - 우클릭 - [Effects] - [Particle System]을 통해 ..."
  },
  
  {
    "title": "유니티 - 포스트 프로세싱 적용하기",
    "url": "/posts/unity-memo-post-processing/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, postprocessing",
    "date": "2021-03-16 17:00:00 +0900",
    





    "snippet": "1. Built-in Pipeline[1] 패키지 설치  Package Manager - Post Processing 설치[2] 레이어 추가  레이어 - Post Processing 추가[3] 메인 카메라 게임오브젝트      컴포넌트 추가 : Post-process Layer        Post-process Layer 컴포넌트          Volume blending - Layer : Post Processing 설정      [4] 포스트 프로세싱 볼륨 게임오브젝트      빈 게임오브젝트 추가        레이어 ..."
  },
  
  {
    "title": "Stencil Silhouette Shader",
    "url": "/posts/unity-shader-script-stencil-silhouette/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:20:00 +0900",
    





    "snippet": "Summary  가려질 경우 단색이 드러나는 실루엣 쉐이더  Ref 2번 사용PreviewSource Code   Silhouette.shader  Shader &quot;Custom/Silhouette&quot;{    Properties    {        _SilhouetteColor (&quot;Silhouette Color&quot;, Color) = (1, 0, 0, 0.5)        [Space]        _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _Ma..."
  },
  
  {
    "title": "Stencil Mask Shader",
    "url": "/posts/unity-shader-script-stencil-mask/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:10:00 +0900",
    





    "snippet": "Summary  스텐실 마스크 &amp;amp; 마스크로 가려야 드러나는 타겟 쉐이더  Ref 1번 사용PreviewSource Code   StencilTarget01.shader  Shader &quot;Custom/StencilTarget01&quot;{    Properties    {        _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}    }    S..."
  },
  
  {
    "title": "Customizable Transparent Shader",
    "url": "/posts/unity-shader-script-transparent-custom/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:00:00 +0900",
    





    "snippet": "Summary  알파 블렌딩, ZTest 등의 옵션을 마테리얼에서 설정할 수 있는 반투명 쉐이더Source CodeShader &quot;Custom/CustomizableTransparent&quot;{    Properties    {        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}                _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _Alpha (&quot;Alpha&quot;..."
  },
  
  {
    "title": "2-Pass Transparent Shader",
    "url": "/posts/unity-shader-script-transparent-2pass/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:00:00 +0900",
    





    "snippet": "Summary  2패스로 작성하여 내부가 드러나는 알파 소팅 문제가 발생하지 않는 쉐이더Source CodeShader &quot;Custom/Transparent2Pass&quot;{    Properties    {        _MainTex(&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}        _Alpha(&quot;Alpha&quot;, Range(0, 1)) = 0.5    }    SubShader    {        Tags { &quot;RenderType..."
  },
  
  {
    "title": "Particle Shader",
    "url": "/posts/unity-shader-script-particle/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 16:00:00 +0900",
    





    "snippet": "Summary  블렌딩 옵션 선택 가능한 파티클 쉐이더(기본 : Additive)Source CodeShader &quot;Custom/Particle&quot;{    Properties    {        _TintColor (&quot;Tint Color&quot;, Color) = (1, 1, 1, 1)        _Intensity(&quot;Intensity&quot;, Range(0, 2)) = 1        _MainTex(&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quo..."
  },
  
  {
    "title": "유니티 - 키보드 연속 입력 유지 상태 감지하기",
    "url": "/posts/unity-memo-double-key-press/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, input, shorts",
    "date": "2021-03-14 23:23:00 +0900",
    





    "snippet": "활용  달리기 구현(WW, AA, SS, DD)Source Code/// &amp;lt;summary&amp;gt; 키보드 연속 입력 유지 상태 감지 &amp;lt;/summary&amp;gt;private class DoubleKeyPressDetection{    public KeyCode Key { get; private set; }    /// &amp;lt;summary&amp;gt; 한 번 눌러서 유지한 상태 &amp;lt;/summary&amp;gt;    public bool SinglePressed { get;..."
  },
  
  {
    "title": "유니티 - Custom Editor (커스텀 에디터)",
    "url": "/posts/unity-editor-custom-editor/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, customeditor",
    "date": "2021-03-13 17:40:00 +0900",
    





    "snippet": "Begin   Custom Editor Example  #if UNITY_EDITORusing System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;[CustomEditor(typeof(SomeScript))]public class SomeScriptEditor : UnityEditor.Editor{    private SomeScript ss;    private void OnEnable()    {..."
  },
  
  {
    "title": "Play Mode Saver (플레이 모드가 끝나도 변경사항 유지)",
    "url": "/posts/unity-play-mode-saver/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, editor, csharp, utility",
    "date": "2021-03-13 17:20:00 +0900",
    





    "snippet": "Summary      등록한 컴포넌트들의 플레이 모드 내 변경사항을 플레이 모드가 종료되어도 유지시킵니다.        변경사항을 적용할 대상들은 Play Mode Saver 컴포넌트 내의 목록으로 관리됩니다.        유니티 에디터 내에서만 동작하며, 빌드 시 Play Mode Saver 컴포넌트는 자동으로 제거됩니다.        플레이 모드 내에서 Play Mode Saver를 수정한 사항도 플레이 모드가 종료되었을 때 유지됩니다.  PreviewHow To Use  변경사항 유지를 원하는 컴포넌트에 우클릭 후, S..."
  },
  
  {
    "title": "유니티 - 하이라키 우클릭 메뉴 아이템",
    "url": "/posts/unity-editor-menu-item-hierarchy/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, editor",
    "date": "2021-03-12 22:50:00 +0900",
    





    "snippet": "우클릭 MenuItem 메소드 중복 호출 방지하기      게임오브젝트를 다중 선택하고 우클릭 메뉴를 통해 실행했을 때 생기는 중복 호출 버그 방지        다이얼로그를 띄우면 방지 안되니 주의  private static string _prevMethodCallInfo = &quot;&quot;;/// &amp;lt;summary&amp;gt; 같은 메소드가 이미 실행됐었는지 검사 (중복 메소드 호출 제한용) &amp;lt;/summary&amp;gt;private static bool IsDuplicatedMethodC..."
  },
  
  {
    "title": "C# - 델리게이트가 특정 메소드를 갖고 있는지 확인하기",
    "url": "/posts/memo-cs-delegate-has-method/",
    "categories": "C#, C# Memo",
    "tags": "csharp, delegate",
    "date": "2021-03-12 21:52:00 +0900",
    





    "snippet": "//using System;//using System.Linq;/// &amp;lt;summary&amp;gt; 델리게이트가 메소드를 갖고 있는지 검사 &amp;lt;/summary&amp;gt;private static bool CheckDelegateHasMethod&amp;lt;DType&amp;gt;(DType @delegate, DType method) where DType : Delegate{    return @delegate?.GetInvocationList()            .Where(d =&amp;gt..."
  },
  
  {
    "title": "유니티 - Menu Item(메뉴 아이템)",
    "url": "/posts/unity-editor-menu-item/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, menuitem",
    "date": "2021-03-12 20:10:00 +0900",
    





    "snippet": "메뉴 아이템 기본private const string MenuItemTitle = &quot;Window/Rito/Menu Item&quot;;private const int MenuItemPriority = 123;[MenuItem(MenuItemTitle)]private static void MenuItem1(){    // ..}[MenuItem(MenuItemTitle, false, MenuItemPriority)]private static void MenuItem2(){    // ..}활성화/비활성화 설정privat..."
  },
  
  {
    "title": "유니티 - Scripting Define Symbol 스크립트로 제어하기",
    "url": "/posts/unity-editor-define-symbol/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, define, symbol",
    "date": "2021-03-12 18:28:00 +0900",
    





    "snippet": "Scripting Define Symbol?      스크립트에서 #define으로 정의하듯, 프로젝트 전체에서 정의하여 사용할 수 있는 심볼        Project Settings - Player - Other Settings - Scripting Define Symbols        빌드 타겟마다 달라진다.        유니티 에디터 스크립팅을 통해 확인, 추가, 제거할 수 있다.  Source Codeusing System.Text.RegularExpressions;using UnityEditor;public sta..."
  },
  
  {
    "title": "C# - 스크립트(.cs), 어셈블리(.dll, .exe) 경로 참조",
    "url": "/posts/memo-cs-get-path/",
    "categories": "C#, C# Memo",
    "tags": "csharp, path",
    "date": "2021-03-12 18:10:00 +0900",
    





    "snippet": "스크립트 경로public static void GetScriptPath([System.Runtime.CompilerServices.CallerFilePath] string filePath = &quot;&quot;){    // 1. Script(.cs) Path    _ = filePath;    // 2. Folder Path    string folderPath = System.IO.Path.GetDirectoryName(filePath);    // 3. Specific Root Folder Path    string ..."
  },
  
  {
    "title": "유니티 - 컴포넌트의 인스펙터 내 순서를 맨 위로 올리기",
    "url": "/posts/unity-editor-component-on-top/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, csharp",
    "date": "2021-03-12 04:04:00 +0900",
    





    "snippet": "bool flag = true;while (flag){    flag = UnityEditorInternal.ComponentUtility.MoveComponentUp(this);    // 맨 위로 올라갔을 경우 false 리턴}"
  },
  
  {
    "title": "유니티 - 플레이모드 상태 변경에 따른 동작 구현하기",
    "url": "/posts/unity-editor-playmode-state-change/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-03-11 03:33:00 +0900",
    





    "snippet": "#if UNITY_EDITORusing System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;namespace Rito{    [InitializeOnLoad]    public class PlayModeStateChangeHandler    {        public static event Action OnExitEditMode;        public static event Action OnEn..."
  },
  
  {
    "title": "Transform Custom Editor(트랜스폼 커스텀 에디터)",
    "url": "/posts/unity-transform-custom-editor/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, csharp, utility, transform",
    "date": "2021-03-10 15:15:00 +0900",
    





    "snippet": "Summary      트랜스폼의 커스텀 에디터        트랜스폼의 로컬 정보 뿐만 아니라, 글로벌 위치, 회전, 크기 값을 확인 및 조작할 수 있습니다.        총 8개의 리셋 버튼으로 트랜스폼의 로컬, 글로벌 값들을 초기화할 수 있습니다.  Preview  Global - Reset 버튼을 누를 경우  Global Position - Reset 버튼을 누를 경우  Global Rotation - Reset 버튼을 누를 경우  Global Scale - Reset 버튼을 누를 경우Download  CustomTran..."
  },
  
  {
    "title": "Weighted Random Picker (가중치 랜덤 뽑기)",
    "url": "/posts/unity-toy-weighted-random-picker/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, random",
    "date": "2021-03-09 03:22:00 +0900",
    





    "snippet": "Note      게임에서 각각 n% 확률로 존재하는 요소들의 뽑기를 수행할 때, 단순히 Random.Range()를 통해서는 계산할 수 없다.        이 때, ‘가중치 랜덤 뽑기’를 이용한다.        제네릭을 활용하여, 아이템들과 가중치의 목록을 넣으면 간단히 뽑기를 수행할 수 있도록 작성하였다.        아이템은 중복되게 추가할 수 없다.        내부적으로 System.Random을 사용한다.  가중치 랜덤 뽑기?      각각의 요소에 가중치(Weight)를 부여한다.        뽑기를 수행했을 때 ..."
  },
  
  {
    "title": "C# - Regex (정규표현식)",
    "url": "/posts/memo-cs-regex/",
    "categories": "C#, C# Memo",
    "tags": "csharp, string, regex",
    "date": "2021-03-08 17:42:00 +0900",
    





    "snippet": "MemoUsingusing System.Text.RegularExpressions;특수문자      ^, \\A : 문자열의 시작        $, \\z : 문자열의 끝        \\d : 10진수 숫자        \\D : 숫자가 아닌 문자        \\b : 단어 경계        \\B : 단어가 아닌 경계        \\s : 공백 문자        \\S : 공백이 아닌 문자        \\w : 단어 문자 ([a-zA-Z_0-9]와 동일할 수 있음)        \\W : 단어가 아닌 문자  기호      [] : 단어..."
  },
  
  {
    "title": "유니티 - 컴파일, 게임 시작 시 실행되는 애트리뷰트 정리",
    "url": "/posts/unity-editor-init-events/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-03-08 03:03:00 +0900",
    





    "snippet": "공통 특징      클래스 또는 메소드 상단에 애트리뷰트를 명시한다.        컴포넌트로 넣지 않고, 스크립트로만 존재해도 실행된다.        정적 클래스나 상속에 관계 없이 동작한다.        메소드 애트리뷰트는 정적 메소드에만 동작한다.  컴파일, 플레이모드 진입 시 실행Note  EditorApplication.isPlaying으로 현재 에디터 모드를 구분하여 활용할 수 있다.[InitializeOnLoad]      using UnityEditor;        클래스 애트리뷰트        정적 생성자가 호..."
  },
  
  {
    "title": "Scene Auto Saver (현재 씬 자동 저장)",
    "url": "/posts/unity-scene-auto-saver/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, csharp, utility, autosave",
    "date": "2021-03-08 02:22:00 +0900",
    





    "snippet": "Summary      일정 시간 주기로 현재 활성화된 씬을 자동 저장합니다.        씬이 저장되지 않은 상태일 때만 타이머가 동작합니다.  How To Use  스크립트 2개를 모두 다운로드 받아 유니티 프로젝트에 넣습니다.      [Window] - [Rito] - [Scene Auto Saver]를 통해 윈도우를 엽니다.    On에 체크/해제하여 기능 실행 여부를 설정할 수 있습니다.  Show Log 옵션으로 자동 저장 시 로그 출력 여부를 설정할 수 있습니다.  Save Cycle 옵션으로 저장 주기를 설정할..."
  },
  
  {
    "title": "유니티 - Custom Editor Window(커스텀 에디터 윈도우)",
    "url": "/posts/unity-editor-custom-editor-window/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, editorwindow",
    "date": "2021-03-08 00:00:00 +0900",
    





    "snippet": "Note  에디터 윈도우를 직접 만들어 사용할 수 있다.PreviewSource Code Example#if UNITY_EDITORusing UnityEngine;using UnityEditor;public class ExampleWindow : EditorWindow{    private bool boolValue;    private float floatValue;    private Vector3 vector3Value;    [MenuItem(&quot;Window/Rito/Example Window&quot;)] //..."
  },
  
  {
    "title": "유니티 - bool 타입 필드를 인스펙터에서 버튼처럼 사용하기",
    "url": "/posts/unity-memo-bool-as-a-button/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, button",
    "date": "2021-03-07 01:33:00 +0900",
    





    "snippet": "인스펙터의 버튼컴포넌트의 인스펙터에서 버튼을 사용하고 싶을 때가 있다.예를 들면 플레이 모드로 진입하지 않고 에디터 모드에서 메소드를 바로 호출 하고 싶을 때.그리고 실제로 커스텀 에디터를 이용해 버튼을 만들 수도 있다.하지만 잠깐 테스트용으로 쓰려는데 스크립트 하나 더 만들고, 커스텀 에디터 선언하고, …심지어 에디터 GUI좀 쓰려면 EditorGUI, EditorUtility, EditorGUILayout, GUIUtility, GUILayout, … 뭐가 이렇게 다양하고 헷갈리게 만들어 놨는지..어쨌든 커스텀 에디터 만들..."
  },
  
  {
    "title": "유니티 - UniRx (Reactive Extensions for Unity)",
    "url": "/posts/unity-study-unirx/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, unirx",
    "date": "2021-03-06 20:14:00 +0900",
    





    "snippet": "개요Rx란?  Reactive Extensions  절차적 프로그래밍에서 다루기 쉽지 않은 비동기 프로그래밍을 손쉽게 다루기 위한 패러다임  .NET에도 다양한 언어로 구현되어 있다.  비동기 데이터 스트림을 중심으로 동작한다.  스트림 내의 데이터에 변화가 발생했을 때 반응형으로 기능이 동작하는 방식을 사용한다.  시간을 상당히 간단하게 취급할 수 있게 된다.  Observer Pattern + Iterator Pattern + Functional ProgrammingUniRx  .NET의 Rx를 유니티에서 사용할 수 없다는..."
  },
  
  {
    "title": "Model Pivot Resetter (모델 임포트 시 피벗 자동 초기화)",
    "url": "/posts/unity-model-pivot-resetter/",
    "categories": "Unity, Unity Editor Utilities",
    "tags": "unity, csharp, model, pivot, postprocessor",
    "date": "2021-03-05 22:22:00 +0900",
    





    "snippet": "Summary  모델링 파일을 유니티로 가져올 때 동작하는 애셋포스트프로세서  모델의 회전과 위치를 리셋하여 기본값으로 지정합니다.  모델의 정점 위치를 모두 계산하여, 피벗이 모델의 중심 하단으로 오도록 설정합니다.How To Use      스크립트를 유니티 프로젝트 내에 넣습니다.        [Window] - [Rito] - [Model Pivot Resetter] - [Activated]를 체크합니다.          체크 해제되어 있을 경우 동작하지 않습니다.        임포트 할 때마다 대화상자를 통해 선택하게..."
  },
  
  {
    "title": "유니티 - 무한 루프를 간편히 방지하기",
    "url": "/posts/unity-memo-prevent-infinite-loop/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp",
    "date": "2021-03-05 04:00:00 +0900",
    





    "snippet": "Note      유니티 엔진에서 무한 루프가 발생하면 에디터가 그대로 멈추어, 강제 종료해야 하는 경험을 겪은 적이 간혹 있을 것이다.        따라서 혹시나 무한 루프가 될 가능성이 있는 코드를 인지했다면 간단한 체크 로직을 넣어주는 것이 좋다.  while( /* condition */ ){    // codes..}이런 코드에서, 간단히 다음처럼 추가해준다.int loopNum = 0;while( /* condition */ ){    // codes..    if(loopNum++ &amp;gt; 10000)   ..."
  },
  
  {
    "title": "유니티 쉐이더 프로퍼티 애트리뷰트 모음",
    "url": "/posts/unity-shader-property-attributes/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, enum, toggle, multicompile",
    "date": "2021-03-04 21:58:00 +0900",
    





    "snippet": "Space[Space(10)]  단순 공백을 크기로 지정한다.Header[Header(Header Text)]  헤더 문자열을 지정한다.  큰따옴표로 묶지 않아야 한다.Toggle[Toggle] _MyToggle (&quot;My Toggle&quot;, Float) = 1.0  체크할 경우 1.0, 체크 해제할 경우 0.0으로 값을 받을 수 있다.IntRange[IntRange] _Value(&quot;Value&quot;, Range(0, 100)) = 50  Range를 정수로 지정할 수 있게 한다.PowerSlider[..."
  },
  
  {
    "title": "Depth Texture Renderer (Z-Buffer 렌더러)",
    "url": "/posts/unity-toy-depth-texture-renderer/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-03-03 19:08:00 +0900",
    





    "snippet": "Note      현재 메인 카메라의 뎁스 텍스쳐를 화면에 렌더링한다.        각 쉐이더의 ZWrite 여부에 관계 없이 모두 렌더링하는 단점이 있다.        렌더 큐 값이 2500(Skybox) 이하인 오브젝트들만 인식한다.  How to Use      DepthRenderer.cs 스크립트를 메인 카메라에 넣는다.        enabled를 체크/해제하여 화면에 렌더 텍스쳐를 보여줄지 여부를 결정할 수 있다.  Preview  원래 화면  뎁스 텍스쳐 렌더링Download  DepthRenderer.zipSo..."
  },
  
  {
    "title": "파티클 시스템 예제 - 06 - Blue Portal [TODO]",
    "url": "/posts/unity-particle-system-example-06-blue-portal/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-03 03:34:00 +0900",
    





    "snippet": "Preview"
  },
  
  {
    "title": "파티클 시스템 예제 - 05 - Dr. Strange Portal",
    "url": "/posts/unity-particle-system-example-05-dr-strange-portal/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-03 03:33:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 계층형 파티클 시스템  2. Portal 이펙트 만들기  3. Spiral A 이펙트 만들기  4. Spiral B 이펙트 만들기  5. Burst 이펙트 만들기  6. 완성Preview목표      계층형 파티클 시스템 만들기        닥터 스트레인지 포탈 이펙트 완성하기  준비물  글로우 모양의 동그란 텍스쳐와 Additive 마테리얼1. 계층형 파티클 시스템지금까지는 이펙트 하나 당 파티클 시스템을 하나씩만 사용해서 제작했다.하지만 대부분의 이펙트는 실제로 하나의 파티클 시스템으로 표현하기..."
  },
  
  {
    "title": "Projectile Shooter (투사체 발사 컴포넌트)",
    "url": "/posts/unity-toy-projectile-shooter/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-03-02 03:28:00 +0900",
    





    "snippet": "Note      마우스 클릭 시 등록된 게임오브젝트를 생성하여, 지정된 방향으로 발사하는 스크립트        생성된 게임오브젝트는 카메라의 시선에 수직인 평면 방향으로 이동하며, 수명이 다하면 제거된다.        오브젝트 풀링이 적용된다.  How To Use      빈 게임오브젝트를 생성하고, ParticleShooter를 컴포넌트로 넣는다.        발사할 대상 게임오브젝트를 Particle Prefab 필드에 넣는다.        Direction으로 발사할 방향을 지정할 수 있다.        Life Ti..."
  },
  
  {
    "title": "Mouse Chaser (마우스 커서 추적 컴포넌트)",
    "url": "/posts/unity-toy-mouse-chaser/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-03-02 03:14:00 +0900",
    





    "snippet": "Note  게임오브젝트가 마우스 커서를 따라오게 하는 스크립트How To Use      마우스 커서를 따라오게 할 게임오브젝트에 컴포넌트로 넣는다.        Distance From Camera를 통해 카메라로부터의 거리를 지정할 수 있다.        Chasing Speed를 통해 마우스를 따라올 속도를 지정할 수 있다.  PreviewSource Code  https://github.com/rito15/Unity_Toys   .  using System.Collections;using System.Collection..."
  },
  
  {
    "title": "파티클 시스템 예제 - 04 - Fire Ball",
    "url": "/posts/unity-particle-system-example-04-fireball/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-02 03:03:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 파티클 시스템 제작  2. 서브 이미터 설정  3. Projectile Shooter 적용  4. 결과Preview목표      Sub Emitters(서브 이미터) 모듈 이해하기        파이어볼 이펙트 만들기  준비물  글로우 모양의 동그란 텍스쳐와 Additive 마테리얼      파이어볼을 발사할 수 있게 해줄 스크립트        아래 소스코드를 다운로드하여 프로젝트 내에 넣어둔다.        ProjectileShooter.zip     Source Code  using System..."
  },
  
  {
    "title": "파티클 시스템 예제 - 03 - Firefly",
    "url": "/posts/unity-particle-system-example-03-firefly/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-01 22:57:00 +0900",
    





    "snippet": "Preview목표      Light 모듈, Collision 모듈 간단히 사용해보고 이해하기        반딧불이 이펙트 만들기  Firefly Effect마테리얼 준비      Addtive        작은 Glow 모양의 텍스쳐  씬 준비  새로운 씬 생성 (Project 우클릭 - Create - Scene)메인 카메라(Main Camera) 설정  Clear Flags : Solid Color  Background : 검정(RGBA 0, 0, 0, 0)으로 설정파티클 시스템 생성      하이라키 우클릭 - Effe..."
  },
  
  {
    "title": "파티클 시스템 예제 - 02 - Mouse Chaser",
    "url": "/posts/unity-particle-system-example-02-mouse-chaser/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-01 21:07:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 기본 준비  2. Heart  3. TwinklePreview기본HeartTwinkle목표  실시간으로 마우스를 따라다니는 예쁜 이펙트 만들기준비물      원하는 모양의 파티클 텍스쳐 (예제에서는 Heart, Twinkle), Additive 마테리얼        파티클이 마우스를 따라오게 만드는 스크립트        아래 소스코드를 다운로드하여 프로젝트 내에 넣어둔다.        MouseChaser.zip     Source Code  using System.Collections;using ..."
  },
  
  {
    "title": "유니티 - 오클루전 컬링",
    "url": "/posts/unity-opt-occlusion-culling/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimization, performance",
    "date": "2021-03-01 01:40:00 +0900",
    





    "snippet": "프러스텀 컬링 (Frustum Culling)      카메라의 뷰 프러스텀(View Frustum) 영역 밖의 오브젝트들은 렌더링하지 않는 것        따로 설정하지 않아도 유니티 내에서 기본적으로 적용된다.  그냥 이렇게 두어도실제로 이렇게 컬링된다.GIF오클루전 컬링 (Occlusion Culling)      다른 오브젝트에 가려진 오브젝트들은 렌더링하지 않는 것        [Window] - [Rendering] - [Occlusion Culling]        Occlusion Culling 윈도우를 통해 설..."
  },
  
  {
    "title": "유니티 - UI 위에 게임오브젝트 띄우기",
    "url": "/posts/unity-memo-gameobject-over-ui/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui",
    "date": "2021-02-28 22:30:00 +0900",
    





    "snippet": "Preview  Green : Default  Red : Over UI1. Built-in Render Pipeline   방법    [1] 레이어 준비      [Over UI] 레이어를 만든다.      [2] Over UI 카메라 준비            카메라를 하나 더 만들고, Audio Listener를 제거한다.              메인 카메라와 함께 움직이려면 메인 카메라의 자식으로 둔다.        Over UI 카메라의 Camera 컴포넌트 설정              Clear Flags : Depth..."
  },
  
  {
    "title": "Free Look Camera (자유 시점 카메라)",
    "url": "/posts/unity-toy-free-look-camera/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-02-28 17:45:00 +0900",
    





    "snippet": "Note  자유롭게 회전, 이동이 가능한 자유 시점 카메라How To Use  카메라가 존재하는 게임오브젝트에 FreeLookCamera 컴포넌트를 추가한다.  게임 시작 후, Left Alt 키를 눌러 커서가 사라지도록 한다.  WASD 키로 카메라를 움직이며, 마우스 이동을 통해 카메라를 회전시킬 수 있다.  QE 키로 카메라를 상하로 움직일 수 있다.PreviewDownload  FreeLookCamera.zipSource Code  https://github.com/rito15/Unity_Toys   .  using S..."
  },
  
  {
    "title": "C# - Enum 관련 메모",
    "url": "/posts/memo-cs-enum/",
    "categories": "C#, C# Memo",
    "tags": "csharp, enum",
    "date": "2021-02-28 04:00:00 +0900",
    





    "snippet": "enum의 모든 요소를 배열로 가져오기enum MyEnum { A, B }// Array에 담기Array allValues = Enum.GetValues(typeof(MyEnum));// MyEnum[]으로 담기MyEnum[] allEnumValues =     Enum.GetValues(typeof(MyEnum))    .Cast&amp;lt;MyEnum&amp;gt;()    .ToArray();enum의 마지막 요소 가져오기// System.Linq;MyEnum last =     Enum.GetValues(typeof(..."
  },
  
  {
    "title": "유니티 - Undo",
    "url": "/posts/unity-editor-undo/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, editor",
    "date": "2021-02-28 01:52:00 +0900",
    





    "snippet": "Note      필드의 값 변경, 리스트나 딕셔너리의 구성요소 변경 : RecordeObject(컴포넌트, &quot;&quot;)        커스텀 에디터에서 대상의 필드를 Undo에 등록하려면, 반드시 해당 필드가 직렬화되어야 한다.  Memo1. 다른 동작에 Undo 등록// 이름 변경, 기타 등등 수행하기 직전에 호출// 주의 : 게임오브젝트의 변경사항은 트랜스폼이 아니라 게임오브젝트를 넣어야 함Undo.RecordObject(target, &quot;Action&quot;);// 오브젝트 생성 직후에 호출Undo...."
  },
  
  {
    "title": "유니티 - 물리 기반 캐릭터 이동 구현하기",
    "url": "/posts/unity-physics-based-movement/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, physics, movement",
    "date": "2021-02-25 04:11:00 +0900",
    





    "snippet": "Note유니티 - 1인칭, 3인칭 전환 가능한 캐릭터 제작하기에서 이어집니다.목차  1. 서론  2. 이동 스크립트 분리  3. 요구사항 정리  4. 필드, 프로퍼티 정의  5. 상태 검사 구현  6. 중력 적용  7. 이동 구현  8. 물리 상호작용  9. 구현 결과  10. 소스 코드서론유니티에서 캐릭터 이동을 구현하기 위한 방법들은 다양하다.  Transform  Rigidbody  Character Controller  NavMeshAgent  …트랜스폼, 내비메시 에이전트를 통해 이동을 구현하면 물리 상호작용을 할 수..."
  },
  
  {
    "title": "파티클 시스템 예제 - 01",
    "url": "/posts/unity-particle-system-example-01/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-23 21:15:00 +0900",
    





    "snippet": "Preview1. Twinkles2. Falling Snowflakes3. Rising Hearts목차  1. Twinkles  2. Falling Snowflakes  3. Rising HeartsTwinkles      우선 반짝이는 모양의 텍스쳐와 Additive 마테리얼을 준비한다.    (텍스쳐 및 마테리얼 준비는 설명을 생략하며, 파티클 시스템 게임오브젝트를 생성한 상태라고 가정한다.)  Transform      파티클 시스템 게임오브젝트를 최초로 생성하면 Rotation X 값이 -90으로 설정되어 있다.    ..."
  },
  
  {
    "title": "파티클 시스템 기초 - 05 - 주요 모듈",
    "url": "/posts/unity-particle-system-tutorial-05/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 22:00:00 +0900",
    





    "snippet": "목차  1. Emission  2. Shape  3. Velocity over Lifetime  4. Color over Lifetime  5. Size over Lifetime  6. Rotation over Lifetime  7. Texture Sheet Animation  References개요  메인 모듈 외의 모듈 중에서 주로 사용되는 모듈들에 대해 소개한다.Emission  파티클의 생성 타이밍과 개수에 관여한다.Rate over Time      초당 생성할 개수를 지정한다.        예시 : [1] vs [4..."
  },
  
  {
    "title": "파티클 시스템 기초 - 04 - 메인 모듈",
    "url": "/posts/unity-particle-system-tutorial-04/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 18:04:00 +0900",
    





    "snippet": "목차  1. Duration, Looping, Prewarm  2. Start Delay  3. Start Lifetime  4. Start Speed      5. Start Size    6. Start Rotation  7. Flip Rotation  8. Start Color  9. Gravity Modifier      10. Simulation Space    11. Simulation Speed  12. Delta Time  13. Scaling Mode  14. Play On Awake      15. Emitt..."
  },
  
  {
    "title": "파티클 시스템 기초 - 03 - 값의 지정 방법",
    "url": "/posts/unity-particle-system-tutorial-03/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 17:04:00 +0900",
    





    "snippet": "목차  1. 값(Value)          Constant      Curve      Random Between Two Constants      Random Between Two Curves        2. 색상(Color)          Color      Gradient      Random Between Two Colors      Random Between Two Gradients      Random Color      1. 값(Value)[1] Constant      기본 설정        고정된 상수 값..."
  },
  
  {
    "title": "파티클 시스템 기초 - 02 - 파티클 속성 기초",
    "url": "/posts/unity-particle-system-tutorial-02/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 15:55:00 +0900",
    





    "snippet": "목차      1. 개요    2. 메인 모듈          Start Lifetime      Start Speed      Start Size      Start Color      Gravity Modifier            3. Emission        4. Shape    5. Renderer개요      파티클 시스템에는 수많은 모듈과 그 속성들이 존재한다.        Duration ~ Ring Buffer Mode 부분은 메인 모듈이라고 부르며 반드시 사용되는 속성들이 존재한다.        Emis..."
  },
  
  {
    "title": "파티클 시스템 기초 - 01 - 파티클 시스템 만들기",
    "url": "/posts/unity-particle-system-tutorial-01/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 15:04:00 +0900",
    





    "snippet": "1. 파티클 시스템 개요      주로 유니티 내에서 VFX(Visual Effect)를 표현하는데 사용한다.        이름이 ‘파티클’이 아니고 ‘파티클 시스템’인 이유는 마치 시스템처럼 하나의 파티클 시스템이 여러 개의 작은 파티클들을 생성 및 관리하기 때문이다.        기본적으로 빈 게임오브젝트에 Particle System 컴포넌트가 추가된 형태로 사용된다.  2. 파티클 시스템 만들기  하이라키 - 우클릭 - Effects - Particle System을 통해 파티클 시스템 게임오브젝트를 생성할 수 있다. ..."
  },
  
  {
    "title": "Git - 로컬 리포지토리 초기 세팅하기",
    "url": "/posts/memo-git-local-repo-initialization/",
    "categories": "Memo, Git",
    "tags": "memo, git, github",
    "date": "2021-02-21 00:00:00 +0900",
    





    "snippet": "조건      깃헙 리포지토리를 새로 생성하는 경우        아무런 파일도 만들지 않고 순수한 상태로 리포지토리를 만든 경우 1번에 해당하며,        Readme.md, LICENCE, .gitignore 등의 파일을 만들었다면 2번에 해당한다.  1. 깃헙에 빈 리포지토리를 생성한 경우  로컬 리포지토리로 사용할 디렉토리에는 다른 파일들 존재한다고 가정한다.깃 로컬 리포지토리로 사용하겠다고 선언한다. (.git 폴더 생성)git init업로드할 파일들을 등록한다.git add .커밋을 등록한다.git commit -..."
  },
  
  {
    "title": "유니티 - Scriptable Object",
    "url": "/posts/unity-editor-scriptable-object/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, scriptableobject",
    "date": "2021-02-20 02:02:00 +0900",
    





    "snippet": "형태[CreateAssetMenu(fileName = &quot;TestSO&quot;, menuName = &quot;ScriptableObjects/Test&quot;, order = 1)]public class TestScriptableObject : ScriptableObject{    public int value = 0;}  상단의 메뉴에서 [Assets] - [Create] - [ScriptableObjects] - [Test] 를 통해 생성 할 수 있게 된다.  프로젝트 윈도우에서 우클릭하면 동일한 메뉴를 확인할..."
  },
  
  {
    "title": "OpenGL 공부 - 23 - Mesh, GameObject Class, Multiple Objects",
    "url": "/posts/opengl-study-23/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-19 16:27:00 +0900",
    





    "snippet": "목표  프래그먼트 쉐이더 수정  Mesh 클래스 작성  GameObject 클래스 작성  여러 개의 게임오브젝트 렌더링1. 프래그먼트 쉐이더 수정      각각의 계산이 독립적이고 순차적으로 수행될 수 있도록 변경한다.        바뀐 구조                  1. 색상 계산(텍스쳐, 버텍스 컬러 등)                    2. 라이트 계산(디퓨즈, 스페큘러, 앰비언트 독립적으로)                    3. 최종 색상 조립(디퓨즈, 스페큘러, 앰비언트 독립적)            소스코드/..."
  },
  
  {
    "title": "C# - 커스텀 애트리뷰트",
    "url": "/posts/memo-cs-custom-attribute/",
    "categories": "C#, C# Memo",
    "tags": "csharp, custom, attribute",
    "date": "2021-02-19 03:55:00 +0900",
    





    "snippet": "필요 네임스페이스using System;using System.Linq;1. 애트리뷰트 클래스 작성[System.AttributeUsage(System.AttributeTargets.Method)]public class CustomAttribute : System.Attribute{    public string Title { get; }    public CustomAttribute(string t) =&amp;gt; Title = t;}2. 타겟 메소드에 애트리뷰트 장착public class TargetClass{    [..."
  },
  
  {
    "title": "C# - Reflection(리플렉션)",
    "url": "/posts/memo-cs-reflection/",
    "categories": "C#, C# Memo",
    "tags": "csharp, reflection",
    "date": "2021-02-19 03:50:00 +0900",
    





    "snippet": "Reflection필요 네임스페이스using System;using System.Reflection;특정 클래스 타입 가져오기Type targetType = Type.GetType(&quot;클래스명&quot;);특정 네임스페이스 내에 있는 클래스 타입 가져오기Type targetType = Type.GetType(&quot;네임스페이스명.클래스명&quot;);특정 네임스페이스의 모든 클래스 타입 가져오기(모든 어셈블리 확인)string asmName = &quot;UnityEngine, Version=0.0.0.0, Cult..."
  },
  
  {
    "title": "OpenGL 공부 - 22 - Light Class",
    "url": "/posts/opengl-study-22/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-18 15:13:00 +0900",
    





    "snippet": "목표  DirectionalLight, PointLight 클래스 작성  프래그먼트 쉐이더에서 각 라이트에 맞는 계산 수행1. Directional Light  위치에 관계 없이 방향으로만 작용하는 직광 만들기DirectionalLight 클래스 작성class DirectionalLight{private:    glm::vec3 direction; // 빛의 방향과 반전된 L 벡터 방향    glm::vec3 color;    float intensity;public:    DirectionalLight(const glm::v..."
  },
  
  {
    "title": "OpenGL 공부 - 21 - Material Class",
    "url": "/posts/opengl-study-21/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-17 22:43:00 +0900",
    





    "snippet": "목표  Material 클래스 작성공부 내용  오브젝트에 적용할 색상과 텍스쳐들을 Material 클래스로 래핑하여 쉐이더에 전달한다.Fragment 쉐이더 수정#version 440#define saturate(x) clamp(x, 0., 1.)struct Material{    vec3 ambient;    vec3 diffuse;    vec3 specular;    sampler2D diffuseMap;};in vec3 vs_position;in vec3 vs_color;in vec2 vs_texcoord;in vec3..."
  },
  
  {
    "title": "게임 서버 엔진",
    "url": "/posts/memo-game-server-engines/",
    "categories": "Memo",
    "tags": "server, engine, gbaas",
    "date": "2021-02-17 21:40:00 +0900",
    





    "snippet": "게임 서버 엔진  완성된 형태의 게임 서버 기능 제공설치형(On-premise, Self-hosted)  ProudNet(국내)          개인 무료 라이센스 제공      마비노기 영웅전, 세븐나이츠 등 190여개 프로젝트에 사용      실시간 대규모 RPG, FPS에 적합      https://www.youtube.com/watch?v=bYB1_qGMRS8&amp;amp;list=PLHmjKJAyeNIdlPra2-dRBhuvqAlun_ir-      http://lab.gamecodi.com/board/zboard..."
  },
  
  {
    "title": "Serverless, BaaS, FaaS",
    "url": "/posts/memo-serverless-baas-faas/",
    "categories": "Memo",
    "tags": "cloud, serverless, baas, faas",
    "date": "2021-02-17 20:40:00 +0900",
    





    "snippet": "애플리케이션 개발 패러다임 변화모놀리스(Monolith)  소프트웨어의 모든 구성요소가 한 프로젝트에 통합된 형태  중앙 집중적 구조  변경이 발생할 경우 전체 애플리케이션을 재배포, 재시작해야 한다.  부분의 장애가 전체 서비스의 장애로 이어지는 경우가 발생한다.  서비스가 커지면 커질수록 전체 시스템 구조 파악이 어려워진다.마이크로 서비스(Micro Service Architecture, MSA)  모놀리스의 단점을 보완하기 위한 구조  애플리케이션을 서비스들의 결합으로 구성한다.  각 서비스는 크기가 작을 뿐, 하나의 모..."
  },
  
  {
    "title": "클라우드 컴퓨팅 3대 서비스",
    "url": "/posts/memo-cloud-computing-services/",
    "categories": "Memo",
    "tags": "cloud, iaas, paas, saas",
    "date": "2021-02-17 20:40:00 +0900",
    





    "snippet": "IaaS, PaaS, SaaS구분  기업과 클라우드 서비스 제공자간의 관리 영역 분할 정도에 따라 구분할 수 있다.선택 예시  IaaS : 인력이 충분하고 자원 및 인프라만 대여하고 싶은 경우  PaaS : 이미 만들어진 런타임, DB 등의 API를 사용하여 본 개발에만 집중하고 싶은 경우  SaaS : 특수목적의 소프트웨어들을 바로 사용하고 싶은 경우IaaS(Infrastructure-as-a-Service)특징      서버 자원, 네트워크, 전력, 스토리지 등의 인프라를 가상화하여 제공한다.        사용한 만큼 지불..."
  },
  
  {
    "title": "C# - 매개변수 한정자 ref, in의 성능",
    "url": "/posts/memo-cs-ref-in-performance/",
    "categories": "C#, C# Memo",
    "tags": "csharp, performance",
    "date": "2021-02-16 23:20:00 +0900",
    





    "snippet": "목표  값타입을 매개변수로 전달할 때 매개변수 한정자 사용에 따른 성능 알아보기(string은 참조타입이지만 매개변수로 전달하면 복제되므로 함께 테스트)테스트 대상public struct StructA{    public long a,b,c,d,e,f,g;    public StructA(long value)    {        a = b = c = d = e = f = g = value;    }}public readonly struct StructB{    public readonly long a,b,c,d,e,f,g; ..."
  },
  
  {
    "title": "OpenGL 공부 - 20 - Texture Class",
    "url": "/posts/opengl-study-20/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-16 22:22:00 +0900",
    





    "snippet": "목표  텍스쳐 클래스화하기텍스쳐 클래스 작성기존에 메소드화하여 사용하던 텍스쳐를 클래스화하려고 한다.function.hpp 파일에 LoadTextureImage() 메소드에 작성했던 내용을 클래스로 옮겨 작성한다.class Texture{private:    GLuint id;    GLenum type;    int width;    int height;public:    Texture(const char* fileName, GLenum type);    ~Texture();    inline const GLuint&amp;..."
  },
  
  {
    "title": "쉐이더그래프로 물 쉐이더 만들기 [작성중]",
    "url": "/posts/shadergraph-water/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, urp",
    "date": "2021-02-16 03:00:00 +0900",
    





    "snippet": "Preview1. 단순 색상2. 큐브맵 매핑References  https://www.youtube.com/watch?v=gRq-IdShxpU&amp;amp;ab_channel=UnityDownload  2021_0214_Water.zip"
  },
  
  {
    "title": "URP에서 쉐이더 코딩하기 [작성 중]",
    "url": "/posts/unity-urp-shader-coding/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, urp",
    "date": "2021-02-15 18:07:00 +0900",
    





    "snippet": "기본 구조  Starting PointShader &quot;RitoURP/VertexFragmentStartPoint&quot;{    Properties    {        _MainTex (&quot;Main Map&quot;, 2D) = &quot;white&quot; {}        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}    }    SubShader    {        Tags         {            &quot;RenderPip..."
  },
  
  {
    "title": "OpenGL 공부 - 19 - Shader, Transform Class",
    "url": "/posts/opengl-study-19/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-15 15:30:00 +0900",
    





    "snippet": "목표  쉐이더, 트랜스폼 클래스화하기1. 쉐이더의 클래스화shader.hpp 작성shader.hpp 파일에 Shader 클래스를 작성한다.기존에 functions.hpp와 main.cpp에서 사용하던 쉐이더 부분을 모두 Shader 클래스로 옮겨준다.// shader.hppclass Shader{private:    GLuint id;    GLuint CompileShader(const GLenum&amp;amp; shaderType, const char* fileDir);    void LinkProgram(const GL..."
  },
  
  {
    "title": "OpenGL 공부 - 18 - Specular, Rim Light",
    "url": "/posts/opengl-study-18/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-14 15:38:00 +0900",
    





    "snippet": "목표  Specular Lighting, Rim Lighting 적용공부 내용필요한 유니폼 변수 전달World View 벡터가 필요하므로, 이를 구하기 위한 카메라 위치를 전달해준다.// main.cppglUniform3fv(glGetUniformLocation(shaderProgram, &quot;cameraPos&quot;), 1, glm::value_ptr(camPos));프래그먼트 쉐이더우선 라이팅 계산을 위한 벡터들을 만들어준다.uniform vec3 lightPos0; // Main Light World Positi..."
  },
  
  {
    "title": "Custom Plane Mesh Generator",
    "url": "/posts/unity-toy-custom-plane-mesh-generator/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, mesh, plane",
    "date": "2021-02-14 03:06:00 +0900",
    





    "snippet": "Note  Plane을 원하는 너비, 해상도로 만들 수 있게 해주는 컴포넌트PreviewHow to Use  빈 게임오브젝트를 생성한다.  PlaneMeshGenerator 컴포넌트를 추가한다.  옵션을 설정하고 마테리얼을 인스펙터의 Material에 넣는다.  Generate 버튼을 누른다.Download  PlaneMeshGenerator.zipSource Code   PlaneMeshGenerator.cs  using UnityEngine;namespace Rito{    public class PlaneMeshGener..."
  },
  
  {
    "title": "물 쉐이더 만들기",
    "url": "/posts/water-shader/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics, water",
    "date": "2021-02-13 19:24:00 +0900",
    





    "snippet": "목표  서피스 쉐이더로 물 쉐이더 만들기목차  1. 물 쉐이더 기초  2. 프레넬 공식 적용  3. 물 흐르게 하기  4. 스페큘러 적용  5. 파도 만들기  6. 투과율 제어하기  7. 최종 결과준비물  큐브맵 텍스쳐 기반 스카이박스  물 노멀맵 텍스쳐  물에 빠질 로봇물 쉐이더 기초메시는 유니티의 기본적인 Plane을 이용한다.노멀은 노멀맵을 넣어 적용하고, 간단히 float로 타일링이 가능하도록 _Tiling 프로퍼티를 추가한다.그리고 _Strength 프로퍼티를 통해 노멀의 강도를 조절할 수 있게 한다.Shader &q..."
  },
  
  {
    "title": "OpenGL 공부 - 17 - Ambient, Diffuse Lighting",
    "url": "/posts/opengl-study-17/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-13 15:32:00 +0900",
    





    "snippet": "목표  Ambient, Diffuse 라이팅 구현공부 내용버텍스에 노멀 정보 추가struct Vertex{    glm::vec3 position;    glm::vec3 color;    glm::vec2 texcoord;    glm::vec3 normal;};Vertex vertices[] ={    // Position                    // Color                     // TexCoord            // Normal                                 ..."
  },
  
  {
    "title": "유니티 - 1인칭, 3인칭 전환 가능한 캐릭터 제작하기",
    "url": "/posts/unity-fps-tps-character/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, fps, tps, controller",
    "date": "2021-02-12 18:06:00 +0900",
    





    "snippet": "목차  1. 하이라키 구성  2. 스크립트 기초  3. 1인칭 이동, 회전  4. 3인칭 이동, 회전  5. 카메라 전환  6. 점프  7. 애니메이션 적용  8. 애니메이션 블렌딩  9. 카메라 전환 시 시점 방향 유지하기  10. 3인칭 카메라 줌 구현  11. 점프 버그 수정  12. 이동 스크립트 분리하기  13. 소스 코드하이라키 구성하기위와 같이 캐릭터의 하이라키를 구성한다.따로 지정하지 않는 이상,모든 게임오브젝트는 Position(0, 0, 0), Rotation(0, 0, 0), Scale(1, 1, 1)로 초..."
  },
  
  {
    "title": "유니티 - 쿨타임 아이콘 UI 만들기",
    "url": "/posts/unity-memo-cooldown-icon-ui/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui, cooldown",
    "date": "2021-02-12 17:13:00 +0900",
    





    "snippet": "목표구현1. 하이라키 구성[1] Outline  Image 컴포넌트 : 원하는 모양의 스프라이트 사용, 아웃라인으로 지정할 색상 적용[2] Mask  RectTransform : Anchor Preset [stretch &amp;amp; stretch] 설정  Left, Top, Right, Bottom 4픽셀 설정  Image 컴포넌트 : Outline과 같은 스프라이트 사용  Mask 컴포넌트 : [Show Mask Graphic] 체크 해제[3] Icon  RectTransform : Anchor Preset [stret..."
  },
  
  {
    "title": "OpenGL 공부 - 16 - Transform, Input",
    "url": "/posts/opengl-study-16/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-12 15:11:00 +0900",
    





    "snippet": "목표  오브젝트 기본 트랜스폼 정의하기  키보드 입력 처리하기트랜스폼 정의트랜스폼의 3요소(위치, 회전, 크기)를 정의한다.glm::vec3 position(0.0f);glm::vec3 rotation(0.0f);glm::vec3 scale(1.0f);그리고 모델 행렬에 트랜스폼 연산을 모두 넣어준다.modelMatrix = glm::translate(modelMatrix, position);modelMatrix = glm::rotate(modelMatrix, glm::radians(rotation.x), glm::vec3(1..."
  },
  
  {
    "title": "유니티 - ILSpy로 유니티 API 구현 뜯어보기",
    "url": "/posts/unity-memo-ilspy/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp, ilspy",
    "date": "2021-02-12 05:32:00 +0900",
    





    "snippet": "다운로드  https://github.com/icsharpcode/ILSpy/releases  vsix를 받을 경우, 비주얼 스튜디오의 확장으로 추가하여 [도구] - [ILSpy]를 통해 바로 실행할 수 있다.사용법      ILSpy를 실행한다.        File - Open으로 대상 어셈블리(dll, exe 등)를 불러온다.        검색을 통해 원하는 클래스, 메소드 등을 빠르게 찾을 수 있다.  유니티 API 구현 뜯어보기C:\\Program Files\\유니티 버전\\Editor\\Data\\Managed\\UnityEn..."
  },
  
  {
    "title": "유니티 - 텍스트 메쉬 프로(TMPro) 사용하기",
    "url": "/posts/unity-memo-textmeshpro/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ugui, ui, text, textmeshpro",
    "date": "2021-02-12 02:09:00 +0900",
    





    "snippet": "특징      SDF(Signed Distance Field)를 이용하여 UGUI 텍스트보다 외곽선을 더 깔끔하게 표현한다.        마테리얼을 이용하여 다양한 효과를 줄 수 있다.        UGUI 텍스트에 비해 성능이 좋다.        미리 고해상도의 Font Texture Atlas를 생성하여 사용하기 때문에 실시간으로 크기가 변경되어도 픽셀을 부드럽게 나타낼 수 있다.  폰트 애셋 생성하기1. 필요 리소스 임포트  [Window] - [TextMeshPro] - [Import Essential Resources..."
  },
  
  {
    "title": "OpenGL 공부 - 15 - View Projection Matrix",
    "url": "/posts/opengl-study-15/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-11 17:05:00 +0900",
    





    "snippet": "목표  View, Projection 행렬 만들고 적용하기공간 변환공간 변환 과정을 간단히 설명하면 다음과 같다.1. Model Transformation  Model -&amp;gt; World모델링의 피벗이 원점인 Local Space(Model Space 또는 Object Space)에 Model Matrix를 곱하면 월드의 특정 좌표가 원점인 World Space의 좌표로 변환된다.2. View Transformation  World -&amp;gt; View카메라의 위치, 방향을 정의한 뒤 World Space에 Vi..."
  },
  
  {
    "title": "OpenGL 공부 - 14 - Model Matrix",
    "url": "/posts/opengl-study-14/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-10 15:20:00 +0900",
    





    "snippet": "목표  Model Matrix에 대한 이해  이동, 회전, 크기 변경공부 내용공통glm의 모델 매트릭스를 선언하는 것으로 시작한다.glm::mat modelMatrix(1.0f);openGL의 Transformation은 기본적으로 4x4 행렬과 vec3로 이루어진다.4x4 행렬과 곱해지려면 벡터 또한 vec4여야 하므로, vec3를 전달하면 내부적으로 vec4(vec3, 1.)을 만들어 연산한다.변환행렬은 서로 곱하여 하나의 변환행렬로 사용할 수 있다.그런데 만약 이동행렬 뒤에 크기행렬을 곱하면 이동값 또한 크기가 변하기 때..."
  },
  
  {
    "title": "유니티 - 에디터 종료 확인 다이얼로그 만들기",
    "url": "/posts/unity-memo-editor-exit-dialog/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, dialog, csharp",
    "date": "2021-02-10 13:50:00 +0900",
    





    "snippet": "Memo기본적으로 유니티 에디터를 종료할 때는 확인창이 뜨지 않고 바로 종료된다.만약 실수로 닫기 버튼을 눌러버린다면 그대로 종료되어 버린다.그런데 유니티 에디터는 에디터의 종료도 이벤트로 구분하여, 메소드를 추가할 수 있도록 구현해놓았기 때문에이를 이용해 에디터의 종료를 시도할 경우 확인창을 띄우도록 할 수 있다.[InitializeOnLoad]public class EditorExitDialog{    static EditorExitDialog()    {        EditorApplication.wantsToQuit ..."
  },
  
  {
    "title": "OpenGL 공부 - 13 - Texture",
    "url": "/posts/opengl-study-13/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-10 01:30:00 +0900",
    





    "snippet": "목표  폴리곤에 텍스쳐 씌워보기(1장, 여러 장)1. 텍스쳐 한 장 사용이미지 준비  프로젝트 디렉토리 내에 Images 폴더를 만들고 PNG 이미지 파일을 준비한다.소스코드 작성  위치 : VertexAttribPointer ~ Main Loop 사이[1] 이미지 로드int imageWidth = 0;int imageHeight = 0;unsigned char* image = SOIL_load_image(&quot;Images/MoonCat.png&quot;,    &amp;amp;imageWidth, &amp;amp;ima..."
  },
  
  {
    "title": "유니티 - 에디터 다이얼로그 창 띄우기",
    "url": "/posts/unity-editor-dialog/",
    "categories": "Unity, Unity Editor Memo",
    "tags": "unity, editor, dialog, csharp",
    "date": "2021-02-09 13:50:00 +0900",
    





    "snippet": "bool res1 = EditorUtility.DisplayDialog(&quot;Title&quot;, &quot;Message&quot;, &quot;OK&quot;);bool res2 = EditorUtility.DisplayDialog(&quot;Title&quot;, &quot;Message&quot;, &quot;OK&quot;, &quot;Cancel&quot;);"
  },
  
  {
    "title": "Custom Mouse Events (성능 향상된 마우스 이벤트 처리)",
    "url": "/posts/unity-toy-custom-mouse-events/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, mouse",
    "date": "2021-02-08 21:54:00 +0900",
    





    "snippet": "구현 동기유니티 모노비헤이비어는 OnMouse로 시작하는 이벤트 메소드들을 작성하여 사용할 수 있다.이 이벤트 메소드들은 레이캐스트 기반으로 동작하며, 해당 마우스 동작이 발생하면 메소드가 호출된다.하지만 여러가지 단점들이 있다.  마우스 좌클릭에 대해서만 동작한다.  이벤트 메소드 작성 시, 비워놓거나 해당 이벤트가 발생하지 않는 상황에도 성능을 소모한다.  컴포넌트를 비활성화하거나, 심지어 게임오브젝트를 비활성화해도 성능을 소모한다.  마우스가 닿은 정확한 위치를 알 수 없다.  대상을 레이어로 필터링할 수 없다.이런 단점..."
  },
  
  {
    "title": "OpenGL 공부 - 12 - New Beginning 3",
    "url": "/posts/opengl-study-12/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-08 16:12:00 +0900",
    





    "snippet": "목표  기본 렌더링 세팅  기본 도형 렌더링공부 내용테스트를 위해 렌더링 옵션들 설정// main.cpp - in main()glEnable(GL_DEPTH_TEST);glEnable(GL_CULL_FACE);glCullFace(GL_BACK);glFrontFace(GL_CCW); // 시계 반대 방향으로 구성된 폴리곤을 전면으로 설정// 픽셀 블렌딩 연산 지정glEnable(GL_BLEND);glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);// GL_LINE : 폴리곤을 선으로 그리기..."
  },
  
  {
    "title": "OpenGL 공부 - 11 - New Beginning 2",
    "url": "/posts/opengl-study-11/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-07 16:12:00 +0900",
    





    "snippet": "목표  프로그램 및 쉐이더 객체 생성  파일에 쉐이더 작성, 불러와 컴파일공부 내용Source Codevertex_core.glsl#version 440layout (location = 0) in vec3 vertex_position;layout (location = 1) in vec3 vertex_color;layout (location = 2) in vec3 vertex_texcoord;out vec3 vs_position;out vec3 vs_color;out vec2 vs_texcoord;void main(){    v..."
  },
  
  {
    "title": "OpenGL 공부 - 10 - New Beginning",
    "url": "/posts/opengl-study-10/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-06 15:20:00 +0900",
    





    "snippet": "목표  다른 강좌로 새롭게 시작  GLM, SOIL2 설치새로운 시작새로운 강좌를 선택한 김에 기존의 파일들을 날려버리고 구조 변경공부 내용GLM ?  OpenGL Mathematics, 수학 라이브러리.  http://glm.g-truc.net/0.9.8/index.html 에서 받을 수 있다.      이제는 익숙하게 Dependencies 폴더에 넣고 GLM 포함경로 설정    libs.h에 아래처럼 추가#include &amp;lt;GLM/glm.hpp&amp;gt;#include &amp;lt;GLM/vec2.hpp&..."
  },
  
  {
    "title": "유니티 반투명, 스텐실 개념 익히기",
    "url": "/posts/unity-transparent-stencil/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics, transparent, alpha, stencil",
    "date": "2021-02-06 01:29:00 +0900",
    





    "snippet": "목차  1. 불투명과 반투명  2. 알파 블렌딩, 알파 소팅  3. 알파 테스트  4. 커스텀 알파 블렌딩  5. 파티클 쉐이더 만들어보기  6. 깨끗한 알파 블렌딩 쉐이더 만들기  7. ZTest와 ZWrite  8. 알파 블렌딩 쉐이더에서 발생하는 문제점들  9. 스텐실  10. References불투명과 반투명불투명(Opaque)과 반투명(Transparent) 오브젝트는 그려지는 타이밍도, 그리기 위한 고려사항도 다르다.유니티에서는 오브젝트를 렌더링하는 순서를 쉐이더와 마테리얼의 렌더 큐(Render Queue)를 통해..."
  },
  
  {
    "title": "유니티 쉐이더 &amp; 함수 모음",
    "url": "/posts/unity-shader-compilation/",
    "categories": "Unity Shader, Shader Memo",
    "tags": "unity, csharp, shader, graphics, transparent, stencil",
    "date": "2021-02-06 01:25:00 +0900",
    





    "snippet": "Functions트랜스폼에서 회전 행렬만 추출하기// 트랜스폼의 회전 행렬 추출float4x4 GetModelRotationMatrix(){    float4x4 rotationMatrix;    vector sx = vector(unity_ObjectToWorld._m00, unity_ObjectToWorld._m10, unity_ObjectToWorld._m20, 0);    vector sy = vector(unity_ObjectToWorld._m01, unity_ObjectToWorld._m11, unity_Object..."
  },
  
  {
    "title": "OpenGL 공부 - 09 - uniform, VAO",
    "url": "/posts/opengl-study-09/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-05 15:20:00 +0900",
    





    "snippet": "목표  uniform 변수, VAO에 대한 이해 및 사용1. uniformuniform이란?  OpenGL에서 쉐이더로 전달하는 글로벌 변수쉐이더에서 uniform 변수 선언 및 사용#shader fragment#version 330 corelayout(location = 0) out vec4 color;uniform vec4 u_Color;void main(){    color = u_Color;};  uniform 변수는 기본적으로 u_를 붙여 네이밍한다.OpenGL에서 uniform 변수 선언 및 전달glGetUnifor..."
  },
  
  {
    "title": "유니티 - 스크립트 최적화",
    "url": "/posts/unity-opt-script-optimization/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimize, optimization, performance",
    "date": "2021-02-04 19:30:00 +0900",
    





    "snippet": "목차  1.  GetComponent(), Find() 메소드 사용 줄이기  2.  GetComponent() 대신 TryGetComponent() 사용하기  3.  Object.name, GameObject.tag 사용하지 않기  4.  비어있는 유니티 이벤트 메소드 방치하지 않기  5.  StartCoroutine() 자주 호출하지 않기  6.  코루틴의 yield 캐싱하기  7.  메소드 호출 줄이기  8.  참조 캐싱하기  9.  빌드 이후 Debug.Log() 사용하지 않기  10  Transform 변경은 한번에  ..."
  },
  
  {
    "title": "유니티 - 프로파일링을 통한 최적화",
    "url": "/posts/unity-opt-profiling/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, profiling, optimization",
    "date": "2021-02-04 19:30:00 +0900",
    





    "snippet": "목차  1. Note  2. Tools  3. Unity Profiler          Custom Profiler Tags      CPU &amp;amp; GPU Boundary      CPU Boundary      GPU Boundary        4. Memory Profiler  5. ReferencesNote  프로파일링은 1차적으로 에디터에서 수행하지만, 타겟 디바이스에서 실제로 실행하며 진행하는 프로파일링이 가장 중요하다.  [Edit - Project Settings - Quliaty - Other]에서..."
  },
  
  {
    "title": "유니티 - 에디터 프로파일러",
    "url": "/posts/unity-opt-profiler-window/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, profiling",
    "date": "2021-02-04 17:50:00 +0900",
    





    "snippet": "목차  1. Unity Profiler  2. CPU Usage          Timeline View      Hierarchy View      Show Related Objects      Call Stack      Show Calls      Deep Profile        3. GPU Usage  4. Rendering  5. MemoryUnity Profiler[Window] - [Analysis] - [Profiler]를 통해 프로파일러 윈도우를 열 수 있다.CPU, GPU(Rendering), Memory..."
  },
  
  {
    "title": "C++ Smart Debugging",
    "url": "/posts/memo-cpp-smart-debugging/",
    "categories": "Memo, Cpp Memo",
    "tags": "cpp",
    "date": "2021-02-04 16:56:00 +0900",
    





    "snippet": "NoteC++에는 미리 정의된 동적 매크로가 있다.__FILE__  해당 위치의 소스파일 경로를 문자열로 가져온다.__LINE__  해당 위치의 줄 번호를 정수로 가져온다.그리고 매크로의 매개변수를 무조건 스트링으로 변환하여 가져올 수 있는 방법이 존재한다.#define MACRO(x) #x  x에 위치한 코드를 문자열로 변환하여 가져온다.이를 이용하면 해당 소스코드와 실행 위치 정보를 간단히 출력할 수 있다.#include &amp;lt;iostream&amp;gt;using namespace std;#define ShowC..."
  },
  
  {
    "title": "OpenGL 공부 - 08 - Debugging",
    "url": "/posts/opengl-study-08/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-04 15:45:00 +0900",
    





    "snippet": "목표  OpenGL 내에서 디버깅하기공부 내용  OpenGL 내에서 에러가 발생하거나 코드를 잘못 작성한 경우, 친절한 에러 메시지보다는 그저 검은 화면을 볼 가능성이 높다.  그래서 디버깅을 하려면, OpenGL에서 제공하는 몇몇 메소드와 매크로를 활용해야 한다.      glGetError          에러가 발생한 경우 에러 플래그를 리턴한다.                  return GLenum      에러 플래그 - GL_NO_ERROR - GL_INVALID_ENUM - GL_INVALID_VALUE - GL..."
  },
  
  {
    "title": "OpenGL 공부 - 07 - Index Buffer",
    "url": "/posts/opengl-study-07/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-03 16:32:00 +0900",
    





    "snippet": "목표  인덱스 버퍼의 사용과 이해공부 내용삼각형 그리기  삼각형을 하나 그리려면, 버텍스 3개가 필요하다.float positions[6] ={    -0.5f, -0.5f,     0.0f,  0.5f,     0.5f, -0.5f,};  GPU는 전달받은 버텍스들을 순서대로 확인하여 3개씩 짝지어서 하나의 폴리곤을 그려준다.  이 때, 3개의 버텍스가 순서대로 시계 반대 방향으로 위치해야 폴리곤의 전면이 그려진다.사각형 그리기  사각형을 하나 그리려면 삼각형이 2개 필요하므로, 결국 버텍스 6개가 필요하다.      그런데..."
  },
  
  {
    "title": "유니티 - 인스펙터에 프로퍼티 표시하기",
    "url": "/posts/unity-memo-show-property-on-inspector/",
    "categories": "Unity, Unity Tips",
    "tags": "unity, csharp, property",
    "date": "2021-02-02 17:08:00 +0900",
    





    "snippet": "Memopublic GameObject Property1 =&amp;gt; Field1;private GameObject Field1;이렇게 다른 필드와 연결된 프로퍼티라면public GameObject Property1 =&amp;gt; field1;[SerializeField]private GameObject field1;대상 필드에 [SerializeField]를 붙여서 인스펙터에 표시할 수 있다.하지만[SerializeField]public GameObject Property2 { get; private set; }프로..."
  },
  
  {
    "title": "OpenGL 공부 - 06 - Shader File",
    "url": "/posts/opengl-study-06/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-02 14:21:00 +0900",
    





    "snippet": "목표  쉐이더를 파일로 분리하여, 파일로부터 읽어와 사용하기공부 내용쉐이더 파일 작성하기  솔루션 디렉터리 - [Resources/Shaders] 폴더 생성  Shaders 폴더 내에 [Basic.shader] 파일 생성  속성 - 디버깅 - 작업 디렉터리에 $(ProjectDir)가 포함되어 있으므로 상대경로에서 불러오기 가능  기존의 쉐이더 코드를 옮겨와 약간 수정하여 내용 작성#shader vertex#version 330 corelayout(location = 0) in vec4 position;void main(){ ..."
  },
  
  {
    "title": "멀티패스 쉐이더 코드 깔끔하게 작성하기",
    "url": "/posts/unity-smart-multipass-code/",
    "categories": "Unity Shader, Shader Memo",
    "tags": "unity, csharp, shader",
    "date": "2021-02-02 00:00:00 +0900",
    





    "snippet": "Shader &quot;A/B&quot;{    Properties    {        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}    }    CGINCLUDE    #include &quot;UnityCG.cginc&quot;    /* Structs */    struct appdata    {        float4 vertex : POSITION;        float2 uv : TEXCOORD0;    };    struct v2f    {      ..."
  },
  
  {
    "title": "C++ 스택 메모리 동적 할당",
    "url": "/posts/memo-cpp-stack-memory-allocation/",
    "categories": "Memo, Cpp Memo",
    "tags": "cpp",
    "date": "2021-02-01 18:45:00 +0900",
    





    "snippet": "Memo      _alloca          스택에 메모리를 동적으로 할당해준다.      함수의 리턴으로 전달하면 안된다.      블록이 종료되면 자동으로 할당 해제된다.      공간 할당 불가능한 경우 Stack Overflow 에러가 발생할 수 있으니 주의      예외가 발생한 경우 구조적 예외처리(SEH)로 받아야 함                  size_t size      할당할 배열 크기(길이 * sizeof(타입))              return void*      할당된 배열의 주소(타입 캐스팅..."
  },
  
  {
    "title": "OpenGL 공부 - 05 - Shader",
    "url": "/posts/opengl-study-05/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-01 17:42:00 +0900",
    





    "snippet": "목표  OpenGL의 쉐이더에 대한 이해  간단한 vertex, fragment 쉐이더 작성, 컴파일 및 실행OpenGL의 쉐이더      Vertex&amp;amp;Fragment Shader          OpenGL에서 거의 90%의 비중을 차지            Vertex Shader          하나의 정점 당 한 번씩 실행된다.      layout을 통해 정점 속성의 위치를 입력받는다.      입력 : 정점 데이터      출력 : 클립 스페이스의 정점 데이터            Fragment Shad..."
  },
  
  {
    "title": "유니티 - UI 헤더 드래그 앤 드롭으로 옮기기",
    "url": "/posts/unity-memo-ui-drag-and-drop/",
    "categories": "Unity, Unity Memo - Shorts",
    "tags": "unity, csharp, ui, memo, drag, drop, shorts",
    "date": "2021-02-01 03:00:00 +0900",
    





    "snippet": "기능  UI의 헤더(윗부분)를 따로 구성했을 때, 헤더를 드래그 했을 때만 옮기기사용법  헤더 UI는 UI의 자식으로 구성한다.  PopupUIHeader 스크립트를 헤더 UI의 컴포넌트로 넣어준다.  이동 대상 UI를 인스펙터에서 Target UI에 넣는다. (지정하지 않는 경우, 부모로 자동 초기화)using UnityEngine;using UnityEngine.EventSystems;/// &amp;lt;summary&amp;gt; 헤더 드래그 앤 드롭에 의한 UI 이동 &amp;lt;/summary&amp;gt;publ..."
  },
  
  {
    "title": "유니티 - 팝업 UI 관리 시스템 구현하기",
    "url": "/posts/popup-ui-management-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, ui, stack",
    "date": "2021-01-31 20:23:00 +0900",
    





    "snippet": "게임의 UI  온라인 PC게임을 예로 들었을 때, 다양한 형태의 UI들이 존재한다.  화면 예시 : Smilegate RPG ‘LostARK’1. 전체화면 UI  크기가 화면 전체에 해당하는 UI  예 : 상점, 캐시 샵2. 고정형 UI  고정된 위치에 항상 존재하는 UI  예 : 하단 바, 퀵슬롯, 미니맵, 채팅창3. 추적형 UI  게임 내 요소들(캐릭터, 몬스터, 건물 등)의 위치를 실시간으로 추적하여 따라다니는 UI  예 : 체력 바, 이름, 말풍선4. 안내형 UI  화면 한켠에 잠시 나타났다가 사라지는 형태의 UI  게..."
  },
  
  {
    "title": "OpenGL 공부 - 04 - VAO, VBO, Attributes",
    "url": "/posts/opengl-study-04/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-31 13:31:00 +0900",
    





    "snippet": "목표  Vertex Attributes, Layout, VBO, VAO에 대한 이해Attributes, VAO, VBO  버텍스 버퍼에는 버텍스 좌표, 텍스쳐 좌표, 노멀 벡터 등 여러 데이터가 float 값으로 들어갈 수 있다.  하지만 그 자체로는 그저 메모리에 올라가는 값일 뿐이기 때문에 각각의 데이터가 어떤 역할을 하고, 길이는 얼마나 갖고 있고, 시작 위치는 어디인지 OpenGL에 알려줘야 한다.      VAO(Vertex Array Object)          하나 이상의 VBO를 담을 수 있는 객체      개..."
  },
  
  {
    "title": "유니티 - 입력 바인딩 시스템 만들기",
    "url": "/posts/input-binding-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, input, binding",
    "date": "2021-01-30 16:18:00 +0900",
    





    "snippet": "목표  에디터 및 인게임에서 언제든 기능에 연결된 사용자 마우스, 키보드 바인딩을 변경할 수 있는 기능 구현  전체 입력 바인딩을 직렬화하여 저장하고 불러올 수 있는 기능 구현유니티의 입력 시스템  유니티에는 2가지 Input System이 있다.  첫 번째는 Input.Get~ 꼴의 메소드를 이용해 이번 프레임에 해당 입력이 있었는지 검사하는 레거시 시스템      두 번째는 2019년 소개된 New Input System.    New Input System을 사용하려면          패키지 매니저에서 Input Syst..."
  },
  
  {
    "title": "OpenGL 공부 - 03 - Vertex, VBO",
    "url": "/posts/opengl-study-03/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-29 22:07:00 +0900",
    





    "snippet": "목표  버텍스, 버텍스 버퍼에 대한 이해렌더링 파이프라인 요약      Vertex Shader          입력 : 정점 목록      정점들을 오브젝트 스페이스에서 MVP 변환을 통해 클립 스페이스까지 변환한다.            Shape Assembly          정점을 조립하여 렌더링을 할 수 있는 최소 단위(Primitive : 점, 선, 삼각형 등)로 만든다.            Geometry Shader          입력 : 프리미티브 목록      프리미티브 당 한 번씩 수행한다.      프리..."
  },
  
  {
    "title": "유니티 - 스크립트 템플릿(Script Templates)",
    "url": "/posts/unity-memo-script-templates/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, script, templates",
    "date": "2021-01-29 16:55:00 +0900",
    





    "snippet": "개념  Project - 우클릭 - Create를 통해 만드는 스크립트 또는 텍스트의 템플릿을 미리 지정하는 기능  스크립트 템플릿의 저장 경로 :C:\\Program Files\\유니티 버전\\Editor\\Data\\Resources\\ScriptTemplates  각각의 유니티 버전마다 따로 저장된다.  한가지 팁은, 스크립트 템플릿에 한 글자라도 애초에 한글이 작성되어 있지 않으면 나중에 한글 주석이라도 작성했을 때 인코딩이 깨져버릴 수 있으니 스크립트 템플릿 내에 아주 짧은 한글 주석을 적어 놓는게 좋다는 것규칙  각각의 템플릿..."
  },
  
  {
    "title": "OpenGL 공부 - 02 - 초기 세팅",
    "url": "/posts/opengl-study-02/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-28 22:09:00 +0900",
    





    "snippet": "목표  GLEW 설치 및 적용GLEW 설치  GLEW : OpenGL Extension Wrangler Library  http://glew.sourceforge.net      Binary 다운로드    프로젝트의 Dependency 폴더 내로 GLEW 폴더 복사          glew-2.1.0 폴더를 통째로 가져와서 GLEW로 이름을 변경해준다.        GLEW/doc/index.html - Usage 탭에 들어가면 초기 사용법이 있다.참조 추가  헤더          프로젝트 속성 - C/C++ - 일반 - 추가..."
  },
  
  {
    "title": "C# - 파일 입출력",
    "url": "/posts/memo-cs-fileio/",
    "categories": "C#, C# Memo",
    "tags": "csharp, file, io",
    "date": "2021-01-28 21:10:00 +0900",
    





    "snippet": "간단 정리파일에 쓰려면  대상이 string, string[], byte[] 타입 중 하나여야 한다.  파일의 전체 경로(&quot;폴더경로\\파일명.확장자&quot;)가 필요하다.한 파일에 대한 연속 입출력 횟수에 따라  한번에 읽거나 쓰려면 File.Read(), File.Write() 메소드를 사용한다.  여러 번에 걸쳐 읽거나 쓰려면 스트림 객체를 사용한다.Namespaceusing System.IO;Path// \\ 대신 /를 써도 \\로 자동 변환string   filePath = @&quot;C:\\folder\\fileN..."
  },
  
  {
    "title": "OpenGL 공부 - 01 - 시작",
    "url": "/posts/opengl-study-01/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-28 00:10:00 +0900",
    





    "snippet": "목표  OpenGL 기초 세팅OpenGL?      OpenGL 자체는 API가 아닌, 각종 OpenGL 라이브러리를 개발하기 위해 Khronos Group이 개발 및 유지 관리하는 설명서이다.        OpenGL은 각 함수의 출력과 수행 방법을 정의한다.        실제로 OpenGL 라이브러리를 개발하는 사람들은 일반적으로 그래픽카드 제조업체이다.        OpenGL은 기본적으로 C언어로 작성되었으며, 각종 확장 라이브러리는 C++로 작성된 경우가 많다.  OpenGL 라이브러리 종류GL(Graphics Lib..."
  },
  
  {
    "title": "Unlit 쉐이더그래프로 만드는 Stylized Lit 쉐이더",
    "url": "/posts/unlit-stylized-lit-shadergraph/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, shadergraph",
    "date": "2021-01-27 22:00:00 +0900",
    





    "snippet": "동기  유나이트 서울 2020의 위 세션을 보고, 쉐이더그래프만을 이용해 비슷하게 만들어 봐야겠다고 생각했다.목표  URP 쉐이더그래프 중 Unlit 그래프를 이용해 직접 Stylized Lit 쉐이더 만들기1. 서브그래프 준비  영상에서 보면, SmoothStep과 비슷한 연산을 더 저렴하게 할 수 있게 해주는 LinearStep을 다룬다.  LinearStep을 함수화하여 자주 사용하는 코드가 나오기에, 서브그래프로 만들어주었다.  그런데 실제로 이 세션의 코드를 보면 LinearStep 내에 threshold, smoot..."
  },
  
  {
    "title": "Frame Rate Checker",
    "url": "/posts/unity-toy-frame-rate-checker/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-01-24 17:00:00 +0900",
    





    "snippet": "Note  실제 FPS 값을 실시간, 최근 N개의 평균, 최소, 최댓값으로 확인할 수 있다.  게임 진행 동안 텍스트의 위치, 색상, 크기, GUI 표시 상태를 실시간으로 변경할 수 있다.PreviewDownload  FrameRateChecker.zipSource Code   .  using System;using System.Collections;using System.Collections.Generic;using UnityEngine;// 날짜 : 2021-01-24 PM 4:11:02// 작성자 : Ritonamespa..."
  },
  
  {
    "title": "유니티 - 잡 시스템(Job System)",
    "url": "/posts/job-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, job, burst",
    "date": "2021-01-24 13:15:00 +0900",
    





    "snippet": "개념  유니티에서 안전한 멀티스레딩을 구현하는 시스템  스레드를 별도로 생성하지 않으며, 유니티의 워커스레드에 작업을 지시할 수 있게 한다.  잡 대기열에 잡을 배치하면 워커 스레드가 잡 대기열에서 항목을 가져와 실행한다.  Native Container를 이용해 잡의 수행 결과를 메인 스레드와 공유한다.  버스트 컴파일러를 이용하여 추가적인 성능 향상을 기대할 수 있다.장점  다수의 작은 작업들을 처리하기에 좋으며, 속도가 빠르다.  스레드를 추가로 만들고 관리하지 않아도 되므로 메모리를 절약할 수 있다.  유니티 콘솔을 이..."
  },
  
  {
    "title": "유니티 - 전장의 안개(Fog of War)",
    "url": "/posts/fog-of-war/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-20 21:00:00 +0900",
    





    "snippet": "목차  1. 개념  2. 구현 방법  3. 타일맵을 이용한 구현  4. 구현 결과  5. 프로파일링, 최적화  6. Reference개념  맵과 크기가 동일한 RGBA(0, 0, 0, a)의 텍스쳐를 이용해 지정한 유닛들의 주변시야를 표현한다.  지정한 유닛이 현재 위치한 원형 범위 내 영역들은 a = 0,  지정한 유닛이 한 번이라도 위치했던 영역들은 a = 0.5~0.8,  지정한 유닛이 한 번도 방문하지 않은 영역은 a = 1로 표현한다.[스타크래프트2 게임 플레이 화면]구현 방법[1] 카메라와 지상 사이에 검정색 Pla..."
  },
  
  {
    "title": "레이 마칭(Ray Marching)",
    "url": "/posts/ray-marching/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-19 23:15:00 +0900",
    





    "snippet": "레이 마칭이란?      메시 데이터를 이용하는 기존의 3D 렌더링 방식과는 달리, 거리 함수(SDF)를 통해 오브젝트의 표면을 정의한다.        카메라로부터 스크린 픽셀들을 향해 레이를 전진시키고(Ray Marching), 해당 픽셀의 레이가 오브젝트 표면에 닿으면 그 픽셀에 오브젝트 표면을 렌더링하는 방식을 사용한다.  SDF  Signed Distance Function  공간 상의 임의의 한 점으로부터 오브젝트 표면까지의 최단 거리를 계산하는 함수  SDF를 통해 3D 오브젝트 표면의 공간상 위치를 정의할 수 있다..."
  },
  
  {
    "title": "Pixelater (픽셀화 렌더링)",
    "url": "/posts/unity-toy-pixelater/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-01-19 22:56:00 +0900",
    





    "snippet": "Note  렌더 텍스쳐의 해상도를 강제로 변경하여 화면을 픽셀화시킨다.  스크립트를 카메라에 부착하여 사용한다.PreviewDownload  Pixelater.zipSource Code   .  using System;using System.Collections;using System.Collections.Generic;using UnityEngine;// 날짜 : 2021-01-19 PM 5:01:57// 작성자 : Ritonamespace Rito{    [ExecuteInEditMode]    public class Pi..."
  },
  
  {
    "title": "AfterImage(Motion Trail, 잔상 효과)",
    "url": "/posts/unity-toy-afterImage/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, afterimage, motiontrail",
    "date": "2021-01-18 22:56:00 +0900",
    





    "snippet": "Note  게임오브젝트가 지나간 자리에 잔상을 생성한다.  하위 게임오브젝트에도 렌더러가 있는 경우, 잔상을 함께 생성할 수 있다.How To Use  대상 게임오브젝트에 Mesh Renderer가 존재하는 경우, MeshAfterImage 스크립트를 부착한다.  Skinned Mesh Renderer가 존재하는 경우, SkinnedMeshAfterImage 스크립트를 부착한다.      After Image Material 필드에 동봉된 AfterImage 마테리얼을 지정한다.    After Image Gradient 옵션..."
  },
  
  {
    "title": "Custom Attributes (커스텀 애트리뷰트 모음)",
    "url": "/posts/unity-toy-custom-attributes/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, custom, attribute",
    "date": "2021-01-17 22:18:00 +0900",
    





    "snippet": "목차  1. MemoBox  2. BoxHeader  3. MethodButton  4. AutoInject  5. Required  6. LayerDropdown, TagDropdown  7. Readonly  8. ProgressBar  9. Label  10. SpaceTop      11. SpaceBottom    Download  Source CodeMemoBox  필드의 상단에 상자 및 메모를 표시한다.            매개변수      설명                  Contents      메모에 적을 ..."
  },
  
  {
    "title": "Unlit 쉐이더그래프로 만드는 Custom Lit 쉐이더",
    "url": "/posts/urp-unlit-custom-lit/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, shadergraph",
    "date": "2021-01-16 22:14:00 +0900",
    





    "snippet": "목표  URP 쉐이더그래프 중 Unlit 그래프를 이용해 직접 Lit 쉐이더 만들기1. Diffuse 구현  커스텀 함수를 이용하여 메인라이트의 방향, 색상, 감쇠를 얻어낸다.Custom_Mainlight.hlslvoid MainLight_half(float3 WorldPos, out half3 Direction, out half3 Color, out half DistanceAtten, out half ShadowAtten){    #if SHADERGRAPH_PREVIEW        Direction = half3(0.5,..."
  },
  
  {
    "title": "유니티 - 비헤이비어 트리(Behavior Tree)",
    "url": "/posts/behavior-tree/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-05 00:26:00 +0900",
    





    "snippet": "개념  FSM (Finite State Machine)의 단점을 보완하기 위해 만들어진 기법  FSM에서는 상태 전이 조건을 모두 각각의 상태에서 검사하지만, BT에서는 상태 동작 뿐만 아니라 전이 조건도 노드로 관리한다.  노드 그래프를 통해 시각화하거나 params, 빌더 패턴 등을 활용하여 스크립트 내에서도 가독성 좋게 구성할 수 있다.  기본적으로 Leaf, Decorator, Composite 노드를 기반으로 하며, 구현은 많이 다를 수 있다.          Leaf : 동작을 수행하는 노드. 대표적으로 Action..."
  },
  
  {
    "title": "유니티 - GC 관련 메모, 팁 모음",
    "url": "/posts/unity-memo-gc/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-01-01 01:01:02 +0900",
    





    "snippet": "String      Object.name 프로퍼티는 호출하는 것 자체만으로 가비지를 하나 생성한다.        GameObject.tag 프로퍼티는 호출하는 것 자체만으로 가비지를 하나 생성한다.          태그 비교 시 반드시 .CompareTag() 메소드를 사용해야 한다.      Component  GetComponent&amp;lt;T&amp;gt;() 메소드는 호출하는 것 자체만으로 가비지를 하나, 에디터에서는 NullErrorWrapper까지 하나 더 생성한다.          반드시 TryGetCompo..."
  },
  
  {
    "title": "유니티 - 유용한 정보, 링크 모음",
    "url": "/posts/unity-memo-useful-links/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-01-01 01:01:01 +0900",
    





    "snippet": "플러그인, 깃헙유니티 스크립트 모음  https://github.com/michidk/Unity-Script-CollectionNewton Json for Unity  https://github.com/jilleJr/Newtonsoft.Json-for-UnityUtf8Json - Fast JSON Serializer  https://github.com/neuecc/Utf8JsonMain Thread Dispatcher  https://github.com/PimDeWitte/UnityMainThreadDispatcherZStri..."
  },
  
  {
    "title": "Rainy Window Shader",
    "url": "/posts/unity-shader-script-rainy-window/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2020-12-01 22:00:00 +0900",
    





    "snippet": "Summary  비내리는 유리창 쉐이더PreviewSource Code   Source Code  Shader &quot;Custom/RainyWindow&quot;{    Properties    {        [HideInInspector] _MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}        _SizeX(&quot;Size X&quot;, float) = 1        _SizeY(&quot;Size Y&quot;, float) = 1        [Spac..."
  },
  
  {
    "title": "Lighting Models",
    "url": "/posts/lighting-models/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics",
    "date": "2020-11-16 17:14:00 +0900",
    





    "snippet": "Vectors  L (Light) : 정점에서 광원을 향하는 방향의 벡터  N (Normal) : 정점의 노멀 벡터  V (View) : 정점에서 카메라를 향하는 방향의 벡터  R (Reflect) : 노멀벡터를 법선으로 하여 계산한 L의 반사 벡터 ( 2N(NdL)-L )      H (Half) : 블린퐁에서 사용, L와 V의 중간 벡터 ( normalize(L + V) )    NdL = dot(N, L) : 기본 램버트 공식  NdV = dot(N, V) : 림라이트에서 사용  RdV = dot(R, V) : 퐁 스페큘..."
  },
  
  {
    "title": "Outline Object",
    "url": "/posts/unity-urp-sg-outline-object/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2020-10-08 00:00:00 +0900",
    





    "snippet": "Summary      CameraDepthNormal 텍스쳐를 이용하여 개별 오브젝트마다 아웃라인을 적용한다.        URP Asset의 Depth Texture에 체크해야 한다.        MSAA 2x 이상 사용해야 한다.  PreviewOptions            프로퍼티      설명                  Main Texture      메인 텍스쳐              Outline Color      아웃라인 색상              Outline Thickness      아웃라인 두께..."
  },
  
  {
    "title": "Toon(Cel)",
    "url": "/posts/unity-urp-sg-toon-cel/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2020-09-30 00:00:00 +0900",
    





    "snippet": "Summary  셀 셰이딩을 통한 카툰 라이팅 표현PreviewOptions            프로퍼티      설명                  Main Texture      메인 텍스쳐              Apply Main Light Color      메인 라이트의 색상 적용 여부 설정              Cel Count      셀 셰이딩 분할 개수              Threshold      셀 셰이딩 기준점 설정              Shadow Color      그림자 색상         ..."
  },
  
  {
    "title": "Singleton MonoBehavior (상속용, 복붙용 싱글톤)",
    "url": "/posts/unity-toy-singleton-monobehavior/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-07-08 15:30:00 +0900",
    





    "snippet": "Note  단순한 상속만으로 모노비헤이비어 클래스를 싱글톤으로 만들어주는 클래스How To Use  클래스명이 Apple일 때 예시로, 다음과 같이 상속받아 사용한다.public class Apple : Rito.SingletonMonoBehavior&amp;lt;Apple&amp;gt;{    // Awake 메소드는 반드시 이렇게 작성해야 한다.    protected override void Awake()    {        base.Awake();        // .. 기타 코드    }}Preview  게임 시작 ..."
  },
  
  {
    "title": "Unity Editor-only Debug (에디터 전용 디버그 클래스)",
    "url": "/posts/unity-toy-editor-only-debug/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-07-06 15:00:00 +0900",
    





    "snippet": "Note  유니티엔진의 콘솔 디버그는 빌드 이후에도 작동하여, 성능을 많이 소모할 수 있다.  이를 방지할 수 있게 유니티 에디터에서만 작동하도록 래핑된 Debug 클래스How To Use  스크립트 상단에 다음과 같이 작성한다.using Debug = Rito.Debug;Download  Debug_UnityEditorConditional.zipSource Code  https://github.com/rito15/Unity_Toys   .  using System;using UnityEngine;using System.Dia..."
  },
  
  {
    "title": "Getcomponent Attributes",
    "url": "/posts/unity-toy-getcomponent-attributes/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-12 23:30:00 +0900",
    





    "snippet": "Note      메소드로만 사용하던 GetComponent(), Find() 기능들을 필드/프로퍼티 애트리뷰트로 간편하게 사용할 수 있다.    리플렉션과 커스텀 애트리뷰트를 활용하여 제작하였다.  Component를 상속받는 타입의 필드/프로퍼티에 사용할 수 있다.  대상 멤버의 접근지정자에 관계 없이 모두 동작한다.  본 애트리뷰트들을 통한 컴포넌트 할당 기능은 Awake() 및 OnEnable() 이후, Start() 이전에 동작한다.  씬 이동, 재시작 시에도 올바르게 동작한다.  Find() 종류의 애트리뷰트들은 게..."
  },
  
  {
    "title": "Save Transform During Play",
    "url": "/posts/unity-toy-save-transform-during-play/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-11 18:10:00 +0900",
    





    "snippet": "Note      기본적으로, 플레이 모드에서 트랜스폼의 위치, 회전, 크기를 변경하여도플레이 모드가 종료되면 변경사항이 저장되지 않는다.        이 컴포넌트를 간단히 추가하기만 하면 플레이 모드를 종료해도트랜스폼의 변경사항이 저장되도록 할 수 있다.  How to Use      원하는 게임오브젝트에 SaveTransformDuringPlay 컴포넌트를 추가하고, On에 체크한다.        플레이 모드에서 On, 각각의 Space 옵션을 수정해도 수정사항이 적용된다.        인스펙터에서 Position Spac..."
  }
  
]

